; Copyright (C) 2015 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns job
  (require (io_lib :as iol) (erlang :as erl :joxify) utils (joxa-core :as jxc)
           (pgsql_manager :as dbif :joxify) (timelib :as ta :joxify) plist)
  (use joxa-records))

(defrecord+ uuid module args status pid start-time end-time state)


(defn+ status-to-enum (st)
  "Convert a status to the enum representation in the RDBMs."
  (case st
    (:live      <<"live">>)
    (:failed    <<"failed">>)
    (:killed    <<"killed">>)
    (:completed <<"completed">>)))


(defn+ enum-to-status (str)
  "Convert en enumeration (represented by a string) to en erlang atom indicating job status."
  (case str
    ({:job_status <<"live">>}      :live)
    ({:job_status <<"failed">>}    :failed)
    ({:job_status <<"killed">>}    :killed) 
    ({:job_status <<"completed">>} :completed)))


(defn sql-to-record (sql-data)
  "Convert the sql representation of the job into a job-record."
  (jxc/let ({uuid-bin mod-bin args-bin status-enum st et state-bin} sql-data)
    (let* (uuid (erl/binary-to-list uuid-bin)
           mod (erl/list-to-atom (erl/binary-to-list mod-bin))
           args (utils/binary-to-term args-bin)
           status (enum-to-status status-enum)
           state (utils/binary-to-term state-bin))
      (make uuid mod args status :null st et state))))


(defn+ retrieve (uuid)
  "Find the job-record in the jobs table."
  (case (dbif/extended-query "select (uuid,module,args,status,pid,start_time,end_time,state) from jobs where uuid = $1" [uuid])
    ({{:select 1} [sql-data]} (sql-to-record sql-data))
    ({{:select 0} _}    :not-found)
    (_                  :error)))


(defn+ insert(jr)
  "Insert a job record into the database table together with additional information extracted from the job arguments."
  (let jr (uuid uuid module mod args args pid pid start-time st)
    (let* (sim-from   (plist/get :sim-from args)
           sim-to     (ta/shift-by sim-from (plist/get :forecast-length-hrs args) :hours)
           num-nodes  (plist/get :num-nodes args)
           ppn        (plist/get :ppn args)
           grid-code  (plist/get :grid-code args))
      (dbif/extended-query "insert into jobs(uuid,module,args,status,start_time,sim_from,sim_to,num_nodes,ppn,grid_code,state) values($1,$2,$3,'live',$4,$5,$6,$7,$8,$9,'[].')"
         [uuid (erl/atom-to-list mod) (utils/term-to-string args) st sim-from sim-to num-nodes ppn grid-code]))))


(defn+ update-state (uuid new-state)
  (dbif/extended-query "update jobs set state = $2 where uuid = $1" [uuid (utils/term-to-string new-state)]))


(defn+ update-status (uuid new-status)
  "Update the status field in the table to a completion status. Note that this is done only once
   at the end of the job, so we can set the end_time as well."
  (dbif/extended-query "update jobs set status = $2, end_time = $3 where uuid = $1"
                       [uuid (status-to-enum new-status) (ta/local-time)]))


(defn+ retrieve-live-jobs ()
  "Retrieve all live jobs."
  (case (dbif/simple-query "select uuid,module,args,status,start_time,end_time,state from jobs where status = 'live'")
    ({{:select _} jobs} (lists/map sql-to-record/1 jobs))
    (_                   :error)))


