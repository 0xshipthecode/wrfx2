(ns logsrv
  (require (error_logger :as logger :joxify) (erlang :as erl :joxify) file
           dict (calendar :joxify) filename gen_server io (io_lib :as iol)
           (joxa-lists :as jxl))
  (use joxa-core))

;; Internal

(defn get-log-device (log-name)
  "Retrieve the PID associated with the log <log-name>."
  (case (gen_server/call :wrfx2logsrv {:get-log-device log-name})
    ({:ok log-dev} log-dev)
    (error (erl/throw (iol/format "logsrv: unknown log ~p" [log-name])))))


;; construct a logging timestamp
(defn timestamp ()
  (let ({{yr mon day}, {hr min sec}} (calendar/local-time))
    (iol/format "~4..0B~2..0B~2..0B:~2..0B~2..0B~2..0B"
                [yr mon day hr min sec])))


(defn level-string (level)
  "Returns a string descriptor of the logging level"
  (case level
    (:info  "info ")
    (:warn  "WARN ")
    (:error "ERROR")
    (:flash "FLASH")
    (_      "FLASH")))


(defn+ level-number (level)
  "Return a number that represents the level <level>."
  (case level
    (:info 0)
    (:warn 1)
    (:error 2)
    (:flash 3)
    (_      3)))


(defn construct-message (level msg args)
  "Construct a standardized messag string from a <level>, <msg> and <args>."
  (let* (text     (iol/format msg args))
    (lists/flatten [(timestamp) " " (level-string level) " " (iol/format msg args) "~n"])))


;; API

(defn+ create-log (log-name)
  "Create a new log stream with name <log-name> that is sent to log-dir/log-name.log
   and also to any <additional-targets>."
  (gen_server/call :wrfx2logsrv {:create-log log-name :info}))


(defn+ close-log (log-name)
  "Close the log <log-name>, this closes the associated io device."
  (gen_server/call :wrfx2logsrv {:close-log log-name}))


(defn+ msg (log-name level msg args)
  "Log message <msg> with args <args> and level <level> to log with name <log-name>."
  (let* (dev       (get-log-device log-name)
         log-text  (construct-message level msg args))
    (io/format dev log-text [])
    ; message is routed to error logger if level is :error or :flash
    (when (gte (level-number level) 2)
      (logger/error-report log-text))))


(defn+ error (level msg &rest args)
  "Log an error with level <level>, message <msg> (with args <args>) to the error logger."
    (logger/error-report (construct-message level msg args)))


(defn+ make-log-f (log-name)
  "Construct a logging function for log <log-name>, the function will take three arguments:
   level, message and arguments.  The last two go into an iol/format/2 call."
  (let* (log-dev (get-log-device log-name))
    (fn (level msg args)
      (let* (text     (iol/format msg args)
             log-text (lists/flatten [log-name " " (timestamp) " " (level-string level) " " (iol/format msg args) "~n"]))
        (io/fwrite log-dev log-text [])))))


(defn+ start-link (log-dir)
  "Start the logging server and construct one default log stream 'system' for general
   messages."
  (gen_server/start_link {:local :wrfx2logsrv} :logsrv [log-dir (dict/new)] [])
  (create-log "system"))


;; gen_server callbacks
(defn+ init (args)
    {:ok args})


(defn+ handle_call (request from state)
  (let ([log-dir dev-map] state)
    (case request
      ; create and manage a new log stream
      ({:create-log log-name min-priority}
        (let* (fname (filename/join [log-dir (erl/++ log-name ".log")]))
          (case (file/open fname [:write])
            ({:ok dev}
              {:reply :ok [log-dir (dict/store log-name dev dev-map)]})
            (error
              {:reply :error state}))))
      ({:get-log-device log-name}
        {:reply (dict/find log-name dev-map) state})
      ({:close-log log-name}
        (case (dict/find log-name dev-map)
          ({:ok dev}
            (file/close dev)
            {:reply :ok [log-dir (dict/erase log-name dev-map)]})
          (:error
            {:reply :no-such-log state})))
      (other
        (logger/error-report (iol/format "logsrv: message ~p not understood, fix it!" [other]))
        {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  (let ([log-dir dev-map] state)
    (dict/map (fn (_ dev) (file/close dev)) dev-map))
  :ok)

(defn+ code_change (old-vsn state extra)
  {:ok state})

