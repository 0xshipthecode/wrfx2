(ns msglog
    (require io 
	     file
	     (erlang :as erl)
	     (joxa-core :as jxc)
	     (calendar :joxify)
	     (io_lib :as iol)))


(defn level-string (level)
  "Returns a string descriptor of the logging level"
  (case level
	(:info "info")
	(:warn "warn")
	(:error "ERROR")
	(:flash "FLASH")))


(defn level-number (level)
  (case level
	(:info 0)
	(:warn 1)
	(:error 2)
	(:flash 3)))


;; send a message to the log with a given level
(defn+ log-msg (pid level msg &rest args)
  (erl/send pid {:msg level (iol/format msg args)})
  :ok)

(defn+ make-log-func (pid)
  "Construct and return a function that sends messages to
   the message log <pid>.  The function has the signature
   (log-function level msg &rest args)."
  (fn (level msg &rest args) (log-msg pid level msg args)))

(defn+ info (pid msg &rest args)
  (erl/send pid {:msg :info (iol/format msg args)})
  :ok)

(defn+ warn (pid msg &rest args)
  (erl/send pid {:msg :warn (iol/format msg args)})
  :ok)

(defn+ error (pid msg &rest args)
  (erl/send pid {:msg :error (iol/format msg args)})
  :ok)

(defn+ flash (pid msg &rest args)
  (erl/send pid {:msg :flash (iol/format msg args)})
  :ok)


;; send an eof request (files are closed)
(defn+ close-log (pid)
  (erl/send pid :eof)
  :ok)

;; send a stop request (files are not closed)
(defn+ stop-log (pid)
  (erl/send pid :exit)
  :ok)

;; construct a logging timestamp
(defn timestamp ()
  (jxc/let ({{yr mon day}, {hr min sec}} (calendar/local-time))
	    (iol/format "~4..0B~2..0B~2..0B:~2..0B~2..0B~2..0B"
		    [yr mon day hr min sec])))



(defn route-message (tgt msg-level text)
  "Relay message <text> at message level <msg-level> to target <tgt> if
   the message level is higher than or equal to the target stream level."
  (let* (msg-level-num (level-number msg-level))
    (case tgt
	  ({:stdio level-num}
	   (when (jxc/gte msg-level-num level-num))
	   (io/format text))
	({:device dev level-num} 
	 (when (jxc/gte msg-level-num level-num))
	 (io/format dev text []))
	({:relay pid level-num}
	 (when (jxc/gte msg-level-num level-num))
	 (erl/send pid {:msg text})))))


;; relay the eof message to all targets
(defn send-eof (tgt close-msg)
  "Interpret the :eof message for the target <tgt>."
  (case tgt
	({:stdio _level}      (io/format close-msg))
	({:device dev _level} (io/format dev close-msg []) (file/close dev))
	({:relay pid _level}  (erl/send pid :eof))))


;; the main logging loop which waits for messages in the form
;; {:msg text} send the text to all targets
;; :eof stop the logging loop and notify all targets of the close
;; NOTE: on :eof all files are closed, the log can be closed without closing
;; the files with an :exit
(defn log-loop (log-n targets)
  (receive
   ({:msg level text}
    ; construct a log text & route message at the given level
    (let* (log-text [log-n "-" (level-string level) " [" (timestamp) "] -> " text "\n"])
      (lists/map (fn (tgt) (route-message tgt level log-text)) targets)
      (log-loop log-n targets)))
   (:eof
    (lists/map (fn (tgt) (send-eof tgt [log-n " [" (timestamp) "] -> *** LOG END ***.\n"])) targets))
   (:exit
    :ok)))



(defn+ start-log (log-n targets)
  "Initiates the message logging subsystem with the name <log-n> and targets
   <targets>, a list that contains elements either {:stdio level-number} or
   {:device dev level-number} or {:relay pid level-number}."
  (erl/spawn (fn () (log-loop log-n targets))))


