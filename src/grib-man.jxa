(ns grib-man
    (require (erlang :as erl :joxify)
	     (joxa-core :as jxc)
	     plist
	     (file :joxify)
	     io
	     lists
	     dict
	     inets
	     gen_server
	     grib-srv
	     grib-def
	     (erl_scan :joxify)
	     (erl_parse :joxify)
	     (erl_eval :joxify)))


(defn+ load-grib-def-file ()
  "Load the GRIB source definition file and scan/parse/evaluate it to retrieve the list
   of GRIB sources to be handled by the GRIB manager."
  (case (file/read-file "etc/grib.sources")
	({:ok cont}
	 (case (erl_scan/string (erl/binary_to_list cont))
	       ({:ok tokens _endpos}
		(case (erl_parse/parse_exprs tokens)
		      ({:ok expr-list}
		       (case (erl_eval/exprs expr-list (erl_eval/new-bindings))
			     ({:value grib-src-list _} grib-src-list)
			     (error error)))
		       (error error)))
	       (error error)))
	(error error)))


(defn+ check-grib-def-file ()
  "Check whether the GRIB def file contains an appropriate expression."
  (case (load-grib-def-file)
	(values (when (erl/is-list values)) :ok)
	(other {:error (io/format "Top-level expression is not a list or error ~p." [other])})))


(defn+ reload-grib-sources ()
  "Reloads the etc/grib.sources file and passes the list of grib sources
   to the GRIB manager, which terminates current servers and starts new servers."
  (let* (file-content (load-grib-def-file))
    (case file-content
	  (grib-source-list (when (erl/is-list file-content))
			    (gen_server/call :grib-man {:restart-grib-servers grib-source-list}))
	  (other {:error "Top-level expression is not a list."}))))


(defn+ start-link (stor-dir log-f)
  "Start the GRIB server manager that routes requests to appropriate GRIB servers."
  (inets/start)
  (gen_server/start_link {:local :grib-man} :grib-man [(dict/new) (dict/new) stor-dir log-f] [])
  (reload-grib-sources))

;; API

(defn+ get-srv-map ()
  (gen_server/call :grib-man :get-srv-map))

(defn+ find-grib-server (src-name)
  "Return the pid of the GRIB server handling the GRIB source named <src-name>."
  (case (gen_server/call :grib-man {:find-grib-server src-name})
	({:ok grib-srv-pid} grib-srv-pid)
	(:error :no-such-server)))


(defn+ get-grib-source (src-name)
  "Return the record (grib-def) of the GRIB source <src-name>."
  (case (gen_server/call :grib-man {:find-grib-source src-name})
	({:ok grib-src} grib-src)
	(:error :no-such-source)))


(defn+ retrieve-gribs (src-name from to at-time delta timeout)
  "Submits a GRIB retrieval request to the GRIB server stored under name <src-name>.  The retrieved GRIB
   files are to cover the time interval from <from> to <to> and be as fresh as possible at time <at-time>.
   Optionally an earlier cycle can be requested by setting delta > 0."
  (let* (log-f (gen_server/call :grib-man :get-log-function))
    (case (find-grib-server src-name)
	  (:no-such-server :no-such-server)
	  (grib-srv-pid (gen_server/call grib-srv-pid {:retrieve-gribs from to at-time delta} timeout)))))


;; Internal functions

(defn start-grib-servers (grib-srcs stor-dir log-f)
  "Start a GRIB server for each dictionary entry in <grib-srcs>."
  (let* (start-one (fn (grib-src stor-dir log-f) (case (grib-srv/start-link grib-src stor-dir log-f) ({:ok pid} pid))))
    (dict/fold (fn (grib-src-name grib-src d) (dict/store grib-src-name (start-one grib-src stor-dir log-f) d))
	     (dict/new) grib-srcs)))

;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn+ handle_call (request from state)
  "Handle a call request (synch request/reply)."
  (jxc/let ([srv-map grib-srcs stor-dir log-f] state)
  (case request
	(:get-log-function {:reply log-f state})
	(:get-srv-map {:reply srv-map state})
	; find the PID of the gen_server managing GRIB source src-name
	({:find-grib-server src-name}
	 {:reply (dict/find src-name srv-map) state})
	; find and return a GRIB source record
	({:find-grib-source src-name}
	 {:reply (dict/find src-name grib-srcs) state})
	; reload GRIB sources file - send kill messages to all current GRIB src and create new ones
	({:restart-grib-servers new-grib-src-list}
	 (log-f :info ["grib-man/handle_call: restarting GRIB servers."])
	 (let* (new-grib-srcs (lists/foldl (fn (x d) (dict/store (grib-def/name x) x d)) (dict/new) new-grib-src-list)
		new-srv-map (start-grib-servers new-grib-srcs stor-dir log-f))
	   ; send termination requests to all current gen_servers
	   (dict/fold (fn (k v a) (gen_server/call v :stop-grib-srv) :ok) :ok srv-map)
	   {:reply :ok [new-srv-map new-grib-srcs stor-dir log-f]}))
	; catch-all reply indicating failure, should be sent to logger
	(other (log-f :warn ["grib-man/handle_call: message ~p not understood." other])
	       {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})
