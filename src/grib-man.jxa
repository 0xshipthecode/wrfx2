(ns grib-man
    (require (erlang :as erl)
	     (joxa-core :as jxc)
	     io
	     lists
	     dict
	     inets
	     gen_server
	     grib-srv
	     grib-def))


(defn start-servers (grib-srcs stor-dir)
  "Start one server per GRIB source and return a dictionary mapping
   GRIB source names to PIDs of the GRIB servers."
  (lists/foldl (fn (gs d) (dict/store (grib-def/name gs) (grib-srv/start_link gs stor-dir) d)) (dict/new) grib-srcs))


(defn+ start_link (grib-srcs stor-dir)
  "Start the GRIB server manager that routes requests to appropriate GRIB servers."
  (inets/start)
  (gen_server/start_link {:local :grib-man} :grib-man [(start-servers grib-srcs stor-dir) grib-srcs stor-dir] []))

;; API

(defn+ retrieve-gribs (src-name from to at-time delta)
  "Submits a GRIB retrieval request to the GRIB server stored under name <src-name>.  The retrieved GRIB
   files are to cover the time interval from <from> to <to> and be as fresh as possible at time <at-time>.
   Optionally an earlier cycle can be requested by setting delta > 0."
  (gen_server/call :grib-man {:retrieve-gribs src-name from to at-time delta}))


;; Internal funcrions

(defn retrieve-grib-files (src-name from to at-time delta srv-map)
  "Routes the retrieve GRIB files request to the grib-srv handling the GRIB source
   with name <src-name>."
  (let* (srv-pid (dict/fetch src-name srv-map))
    (grib-srv/retrieve-gribs srv-pid from to at-time delta)))


(defn find-grib-src (name grib-srcs)
  "Find a grib source by name <name> in the list of grib sources <grib-src>."
  (case grib-srcs
	((gs . rest)
	 (case (grib-def/name gs)
	       (name gs)
	       (_wrongname (find-grib-src name rest))))))

;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn+ handle_call (request from state)
  (jxc/let ([srv-map grib-srcs stor-dir] state)
  (case request
	({:retrieve-gribs src-name from-time to-time at-time delta}
	 {:reply (retrieve-grib-files src-name from-time to-time at-time delta srv-map) state})
	; catch-all reply indicating failure, should be sent to logger
	(other {:reply {:error (io/format "message ~p not understood." [other])} state})))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})
