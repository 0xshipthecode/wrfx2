; Copyright (C) 2015 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns taskinfo
  (use joxa-records))

(defrecord+ uuid job-type task-name start-time end-time result info)

(ns perftrack
  (require (erlang :as erl :joxify) lists (timelib :as ta) taskinfo (io_lib :as iol)
            (file :joxify) (pgsql_manager :as dbif :joxify))
  (use joxa-core utils))


(defn+ initialize ()
  "Ensures all tables are available."
  (critical-check :true (table-exists? "taskinfo"))
  (log-info "perftrack: initialized, tables available." []))


(defn+ append-task-info (job-module uuid task-name start-time end-time result info)
  "A shortcut that makes it unnecessary to require taskinfos for clients using this module."
  (dbif/extended-query "insert into taskinfo(uuid,job_type,task_name,start_time,end_time,result,info) values ($1,$2,$3,$4,$5,$6,$7)"
    [uuid (erl/atom-to-list job-module) task-name start-time end-time (term-to-string result) (term-to-string info)]))


(defn+ append-task-info (ti)
  "Appends the taskinfo <pr> to the table :taskinfo.  This function can be used to append performance
   records gathered by mechanisms outside of the scope of the perfmon."
  (taskinfo/let ti (uuid uuid job-type jt task-name tn start-time st end-time et result res info info)
    (append-task-info jt uuid tn st et res info)))


(defn+ get-task-stats (job-type task-name)
  "Retrieves the performance statistics (avg, min, max) for task <task-name> executed within <job-type>."
  (let* (res (dbif/extended-query "select extract('epoch' from avg(end_time - start_time)),
                                          extract('epoch' from min(end_time - start_time)),
                                          extract('epoch' from max(end_time - start_time))
                                          from taskinfo where job_type=$1 and task_name=$2" [job-type task-name]))
    (case res
      ({{:select 1} [{avg} {min} {max}]}
        {avg min max})
      (_ :error))))


(defn+ instrument-as (job-type uuid task-name info task-f)
  "Instrument the function <task-f> and log the start/end/result into the :taskinfo table with the job name <job-type>,
   unique identifier <uuid>, task id <task-name> and additional information <info>. If the task throws an exception,
   it is caught, stored as {:exception exc-type exc-body} and rethrows the exception, otherwise the result is stored as
   {:returned result}."
  (let* (start-time (ta/local-time))
    (try*
      (let* (result (task-f))
        (append-task-info job-type uuid task-name start-time (ta/local-time) {:returned result} info)
        result)
    (catch (class body)
      (do
        (append-task-info job-type uuid task-name start-time (ta/local-time) {:exception class body} info)
        ; it's not clear how to handle catching only some types of exceptions in joxa, so we catch/log everything here
        ; and rethrow the exception (even if it wasn't a throw in the first case)
        (erl/throw body))))))


(defn+ instrument-as (job-type uuid task-name task-f)
  "Instrument the function <task-f> and store results under <job-type> and <task-name>."
  (instrument-as job-type uuid task-name [] task-f))

