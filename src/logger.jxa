(ns logger
  (require io file lists
	         (erlang :as erl :joxify)
	         (calendar :joxify)
	         (io_lib :as iol))
  (use joxa-core))


(defn level-string (level)
  "Returns a string descriptor of the logging level"
  (case level
    (:info  "info ")
    (:warn  "WARN ")
    (:error "ERROR")
    (:flash "FLASH")
    (_      "FLASH")))


(defn+ level-number (level)
  "Return a number that represents the level <level>."
  (case level
    (:info 0)
    (:warn 1)
    (:error 2)
    (:flash 3)
    (_      3)))


(defn+ log-msg (pid level msg)
  (erl/send pid {:msg level msg})
  :ok)


(defn+ log-msg (pid level msg &rest args)
  (erl/send pid {:msg level (iol/format msg args)})
  :ok)


(defn+ make-log-func (pid)
  "Construct and return a function that sends messages to
   the message log <pid>.  The function has the signature
   (log-function level &rest msg-args)."
  (fn (level args)
      (case args
	      ([msg] (when (erl/is-list msg)) (erl/send pid {:msg level (lists/flatten msg)}))
	      ((msg . rest) (when (erl/is-list msg)) 
	        (erl/send pid {:msg level (lists/flatten (iol/format msg rest))}))
	      (gibberish (erl/send pid {:msg :flash (iol/format "INVALID message [~p], fix this!" [gibberish])})))))


;; send an eof request (files are closed)
(defn+ close-log (pid)
  (erl/send pid :eof)
  :ok)

;; send a stop request (files are not closed)
(defn+ stop-log (pid)
  (erl/send pid :exit)
  :ok)

;; construct a logging timestamp
(defn timestamp ()
  (let ({{yr mon day}, {hr min sec}} (calendar/local-time))
    (iol/format "~4..0B~2..0B~2..0B:~2..0B~2..0B~2..0B"
                [yr mon day hr min sec])))


(defn route-message (tgt msg-level log-text text)
  "Relay message <text> or <log-text> at message level <msg-level> to target <tgt> if
   the message level is higher than or equal to the target stream level.
   <text> is sent to :relay targets while <log-text> is sent to other targets."
  (let* (msg-level-num (level-number msg-level))
    (case tgt
      ({:stdio level-num}
        (if (gte msg-level-num level-num) (io/format log-text) :ok))
      ({:device dev}
        (io/format dev log-text []) :ok))))


;; relay the eof message to all targets
(defn send-eof (tgt close-msg)
  "Interpret the :eof message for the target <tgt>.
   NOTE: :eof messages are not propagated to :relay targets."
  (case tgt
    ({:stdio _level}
      (io/format close-msg))
    ({:device dev}
      (io/format dev close-msg []) (file/close dev))))


;; the main logging loop which waits for messages in the form
;; {:msg text} send the text to all targets
;; :eof stop the logging loop and notify all targets of the close
;; NOTE: on :eof all files are closed, the log can be closed without closing
;; the files with an :exit
(defn log-loop (log-n targets)
  (receive
    ({:msg level text}
      ; construct a log text & route message at the given level
      (let* (log-text [log-n " " (timestamp) " " (level-string level) " " text "~n"])
        (lists/map (fn (tgt) (route-message tgt level (lists/flatten log-text) text)) targets)
        (log-loop log-n targets)))
    (:eof
      (lists/map (fn (tgt) (send-eof tgt [log-n " [" (timestamp) "] -> *** LOG END ***.~n"])) targets))
    (:exit
      :ok)))


(defn+ start-log (log-n targets)
  "Initiates the message logging subsystem with the name <log-n> and targets
   <targets>, a list that contains elements either {:stdio level-number} or
   {:device dev level-number} or {:relay pid level-number}."
  (erl/spawn (fn () (log-loop log-n targets))))


(defn+ make-dev-target (fname)
  "Create a device target for the log stream (always sinks all messages)."
  (case (file/open fname [:write])
    ({:ok dev} 
      (io/format "in make-dev-target dev ~p opts ~p~n" [dev (io/getopts dev)])
      {:device dev})
    (error :failed)))


(defn+ start (log-n fname)
  "Start the log <log-n> with one file target <fname>."
  (erl/spawn (fn () (log-loop log-n [(make-dev-target fname)]))))
