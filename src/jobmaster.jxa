; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns livejob
  (use joxa-records))

(defrecord+ uuid module args pid state)

(ns jobresult
  (use joxa-records))

(defrecord+ uuid module args result)


(ns jobmaster
  (require utils plist logsrv filesys filename configsrv livejob jobresult
           lists (string :as str) gen_server (file :joxify) (timelib :as ta) (mnesia :joxify)
           (dict :joxify) (erlang :as erl :joxify) (io_lib :as iol) os)
  (use joxa-core utils))


(defn+ start-link ()
  "Ensure tables :livejob :jobresult are initialized and ready.  Then globally register
   the jobmaster and resubmit all jobs that did not complete yet."
  (critical-check :ok (ensure-table-exists (:livejob . (record-fields (livejob/field-info))) []))
  (critical-check :ok (ensure-table-exists (:jobresult . (record-fields (jobresult/field-info))) []))
  (critical-check :ok (mnesia/wait-for-tables [:livejob :jobresult] 10000))
  (gen_server/start_link {:global :jobmaster} :jobmaster {(logsrv/make-log-f "system")} [])
  (gen_server/call {:global :jobmaster} :resubmit-live-jobs))


(defmacro check-transaction (do-f trans-id on-success)
  "Anaphoric macro (binds 'result' to the result of the transaction if successfull and if it fails,
   it flashes a message to the system stream and returns :error.  More information
   is not retrieved as it is unlikely the client will be able to fix this problem."
  (let* (reason (gensym))
    `(case (mnesia/transaction (fn () ~do-f))
      ({:atomic  result} ~on-success)
      ({:aborted ~reason}
        (logsrv/msg "system" :flash "jobmaster: mnesia transaction ~p aborted with reason ~p, system may be in inconsistent state!" [~trans-id ~reason])
        :error))))


;; --------------------------------------------
;; public API
;; --------------------------------------------


(defn+ job-done (uuid)
  "Notify the jobmaster that the job <uuid> is complete."
  (gen_server/call {:global :jobmaster} {:job-done uuid}))


(defn+ submit (uuid mod args)
  "Submits a job by executing <mod>/submit with args <args>.
   Returns the job id (a uuid)."
  (gen_server/call {:global :jobmaster} {:submit-job uuid mod args}))


(defn+ livejobs ()
  "Retrieve a list of live jobs from the live jobs table."
  (check-transaction (mnesia/all-keys :livejob) "livejobs" result))


(defn+ islive? (uuid)
  "Check if the <uuid> exists in the live jobs table.  Returns :error if transaction fails."
  (check-transaction (mnesia/read {:livejob uuid}) "islive?" (erl/not (empty? result))))


(defn+ getstate (uuid)
  "Retrieve the state of the job <uuid>, assuming its live."
  (check-transaction
    (case (mnesia/read :livejob uuid)
      ([jlj] (livejob/state jlj))
      ([]   :no-such-job))
    "getstate"
    result))


(defn modify-state (uuid trans-name modify-f)
  "Modify the state of the job <uuid>.  Use name <trans-name> to identify the transaction.
   The modification is mediated by the <modify-f> function."
  (check-transaction
    (case (mnesia/read :livejob uuid)
      ([jlj]
        (let* (state1 (modify-f (livejob/state jlj)))
          (mnesia/write (livejob/state! jlj state1))))
      ([] :no-such-job)
      (:error :error))
    trans-name
    result))


(defn+ removestate (uuid keys)
  "Remove the keys <keys> from the state of job with id <uuid>."
  (modify-state uuid "removestate" (fn (js) (plist/remove-list keys js))))


(defn+ updatestate (uuid new-state)
  "Internal function to update the state of live job <uuid> with the state <new-state>."
  (modify-state uuid "updatestate" (fn (js) (plist/update-with new-state js))))


(defn+ kill (uuid)
  "Kill the job <uuid> if it still running.
  The reason is specified as :by-request.
  Job is not removed from the jobmaster lists."
  (gen_server/call {:global :jobmaster} {:kill-job uuid :by-request}))


;; --------------------------------------------
;; internal function
;; --------------------------------------------

(defn getjobpid (uuid)
  "Retrieve the pid of the job <uuid>, assuming its live."
  (check-transaction
    (case (mnesia/read {:livejob uuid})
      ([js]   (livejob/pid js))
      ([]     :no-such-job))
    "getjobpid"
    result))


(defn retrieve-live-job (uuid)
  "Retrieve a live job <uuid> from the livejob table."
  (check-transaction
    (mnesia/read {:livejob uuid})
    "retrieve-live-job"
    (case result ([js] js) ([] :no-such-job))))


;; submit a job by the jobmaster
(defn execute-job-internal (mod args)
  "Execute a job inside a new process."
  (let* (uuid (plist/get :uuid args))
    (logsrv/create-log uuid)
    (erl/spawn (fn ()
      (try*
        (let* (work-dir (filename/join (configsrv/get-conf :workspace-dir) uuid))
          (!!= :ok (filesys/create-dir work-dir))
          (erl/apply mod :run [(plist/set :work-dir work-dir args) (logsrv/make-log-f uuid)])
          (jobmaster/updatestate uuid [{:result "SUCCESS"} {:jmts (ta/local-time)}]))
      (catch (type body)
        (case body
          ({:killed :by-request}
            (logsrv/msg "system" :info "job [~s] was killed by request." [uuid])
            (jobmaster/updatestate uuid [{:result "KILLED"} {:reason "killed by request"} {:jmts (ta/local-time)}]))
          ({:killed with-reason}
            (logsrv/msg "system" :error "job [~s] was killed with reason ~p.~n" [uuid with-reason])
            (jobmaster/updatestate uuid [{:result "KILLED"} {:reason (lists/flatten (iol/format "killed with reason ~p" [with-reason]))} {:jmts (ta/local-time)}]))
          (_
            (jobmaster/updatestate uuid [{:result "FAILED"} {:reason (lists/flatten (iol/format "crashed with exception type ~p body ~p" [type body]))}])
            (logsrv/msg "system" :error "job [~s] crashed (exception type: ~p~nbody: ~p)~nstacktrace:~n~p~n"
                        [uuid type body (erl/get-stacktrace)])))))
      ; whatever happens, the log gets closed
      (logsrv/close-log uuid)
      ; notify the server process that the job is done (and is to be removed from the set of live jobs
      (job-done uuid)))))


(defn all-live-job-records()
  (check-transaction (mnesia/foldl (fn (entry acc) (entry . acc)) [] :livejob)
                     "jobmaster: retrieve records of all live jobs" result))


;; --------------------------------------------
;; gen_server callbacks
;; --------------------------------------------

(defn+ init (args)
  {:ok args})


;; the jobmaster keeps tabs on all running and ended jobs by keeping
;; track of the tuple {uuid job-pid job-state}
;;
(defn+ handle_call (request from state)
  (let ({log-f} state)
    (case request
      ; submit a new/existing job (matched by uuid)
      ({:submit-job uuid mod args}
        (if (islive? uuid)
          (do
            (log-f :info "jobmaster: did not start job ~p, it is already live" [uuid])
            {:reply {:ok uuid} state})
          (do
            (let* (args2   (plist/update-with [{:uuid uuid} {:short-uuid (str/substr uuid 1 8)}] args)
                   job-pid (execute-job-internal mod args2))
              (log-f :info "jobmaster: job ~p is going LIVE now." [uuid])
              {:reply (check-transaction (mnesia/write (livejob/make uuid mod args2 job-pid [])) "submit-job" {:ok uuid}) state}))))
      ; notification that a job has been deactivated (from the job)
      ({:job-done uuid}
        (log-f :info "jobmaster: notified that job ~p is done" [uuid])
        {:reply
          (check-transaction
            (let ([jlj] (mnesia/read {:livejob uuid}))
              (mnesia/write (jobresult/make uuid (livejob/module jlj) (livejob/args jlj) (livejob/state jlj)))
              (mnesia/delete {:livejob uuid}))
            "job-done"
            result)
           state})
      ; kill the job uuid
      ({:kill-job uuid with-reason}
        (case (getjobpid uuid)
          (jpid (when (erl/is-pid jpid))
            (erl/send jpid {:kill with-reason})
            (log-f :info "jobmaster: killing job ~p with reason ~p." [uuid with-reason])
            {:reply :ok state})
          (some-error
            {:reply some-error state})))
      ; resubmit libe jobs
      (:resubmit-live-jobs
        (lists/map (fn (lj) (let* (uuid   (livejob/uuid lj)
                                   module (livejob/module lj)
                                   args   (livejob/args lj))
                              (log-f :info "jobmaster: resubmitting live job ~p (module ~p)." [uuid module])
                              (execute-job-internal module args))) (all-live-job-records))
        {:reply :ok state})
      ; message not understood
      (other
        (logsrv/error :flash "jobmaster: message ~p not understood, fix it!" [other])
        {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

