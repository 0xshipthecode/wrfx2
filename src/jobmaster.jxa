(ns jobmaster
  (require utils plist jobstate logsrv
           lists (string :as str) gen_server filename (file :joxify)
           (dict :joxify) (erlang :as erl :joxify))
  (use joxa-core utils))


(defn+ start-link ()
  (gen_server/start_link {:global :jobmaster} :jobmaster {(dict/new) [] (logsrv/make-log-f "system")} []))

;; API

(defn+ addjob (job-id job-pid job-state)
  "Add a job with name <job-id> and process <job-pid> and job state <job-state>."
  (gen_server/call {:global :jobmaster} {:add-job job-id job-pid job-state}))


(defn+ deljob (job-id)
  "Remove the job named <job-id> from the master index."
  (gen_server/call {:global :jobmaster} {:remove-job job-id}))


(defn+ getjobstate (job-id)
  "Retrieve the pid of the jobstate server for job named <job-id>."
  (gen_server/call {:global :jobmaster} {:job-state job-id}))


(defn+ getjobpid (job-id)
  "Retrieve the pid of the job named <job-id>."
  (gen_server/call {:global :jobmaster} {:job-pid job-id}))


(defn+ listjobs ()
  "List all jobs currently indexed by the jobmaster."
  (gen_server/call {:global :jobmaster} :list-jobs))


(defn+ activejobs()
  "Returns the active jobs."
  (gen_server/call {:global :jobmaster} :active-jobs))


(defn+ submitjob (mod args)
  "Submits a job by executing <mod>/submit with args <args>.
   Returns the job id (a uuid)."
  (gen_server/call {:global :jobmaster} {:submit-job mod args}))


(defn+ resubmitjob (uuid mod args)
  "Resubmit a job with the given <uuid>."
  (gen_server/call {:global :jobmaster} {:resubmit-job uuid mod args}))


;; Internal funcrions


;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn+ handle_call (request from state)
  (let ({job-dict active-jobs log-f} state)
   (case request
    ({:add-job job-id job-pid job-state}
      {:reply :ok {(dict/store job-id {job-pid job-state} job-dict) active-jobs log-f}})
    ({:remove-job job-id}
      ; here a termination must be started
      {:reply :ok {(dict/erase job-id job-dict) active-jobs log-f}})
    ({:job-state job-id}
      (try*
        {:reply (erl/element 2 (dict/fetch job-id job-dict)) state}
        (catch (type bdy)
          {:reply :no-such-job state})))
    ({:job-pid job-id}
      (try*
        {:reply (erl/element 1 (dict/fetch job-id job-dict)) state}
        (catch (t b)
          {:reply :no-such-job state})))
    (:list-jobs
      {:reply (dict/fetch-keys job-dict) state})
    ({:submit-job mod args}
      (if (empty? active-jobs)
        (let* (uuid       (utils/make-uuid)
               short-uuid (str/substr uuid 1 8)
               args2      (plist/update-with [{:job-id uuid} {:short-job-id short-uuid}] args)
               jst-pid    (jobstate/start-link uuid)
               job-pid    (erl/apply mod :submit [args2 jst-pid]))
          (log-f :info "jobmaster: job ~p activated" [uuid])
          {:reply {:ok uuid jst-pid} {(dict/store uuid {job-pid jst-pid} job-dict) (uuid . active-jobs) log-f}})
        {:reply :busy state}))
    ({:resubmit-job uuid mod args}
      (let* (short-uuid (str/substr uuid 1 8)
             args2      (plist/update-with [{:job-id uuid} {:short-job-id short-uuid}] args)
             jst-pid    (jobstate/start-link uuid)
             job-pid    (erl/apply mod :submit [args2 jst-pid]))
        {:reply {:ok uuid jst-pid} {(dict/store uuid {job-pid jst-pid} job-dict) active-jobs log-f}}))
    ({:job-activated uuid}
      (if (erl/not (lists/member uuid active-jobs))
        (do
          (log-f :info "jobmaster: job ~p activated" [uuid])
          {:reply :ok {job-dict (uuid . active-jobs) log-f}})
        {:reply :ok state}))
    ({:job-deactivated uuid}
      (io/format "JOBMASTER: received deactivation message for job ~p~n" [uuid])
      (log-f :info "jobmaster: job ~p done" [uuid])
      {:reply :ok {job-dict (lists/delete uuid active-jobs) log-f}})
    (:active-jobs
      {:reply active-jobs state})
    (other
      (logsrv/error :flash "jobmaster: message ~p not understood, fix it!" [other])
      {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

