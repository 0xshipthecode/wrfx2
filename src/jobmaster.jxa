; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns jobmaster
  (require utils plist logsrv
           lists (string :as str) gen_server filename (file :joxify)
           (dict :joxify) (ets :joxify) (erlang :as erl :joxify) (io_lib :as iol) os)
  (use joxa-core utils))


(defn+ start-link ()
  (gen_server/start_link {:global :jobmaster} :jobmaster {:no-table [] (logsrv/make-log-f "system")} []))

;; API


(defn+ job-done (job-id)
  "Notify the jobmaster that the job <job-id> is complete."
  (gen_server/call {:global :jobmaster} {:job-done job-id}))


(defn+ addjob (job-id job-pid info-plist)
  "Add a job with name <job-id> and process <job-pid> and current job state plist <info-plist>."
  (gen_server/call {:global :jobmaster} {:add-job job-id job-pid info-plist}))


(defn+ deljob (job-id)
  "Remove the job named <job-id> from the master index."
  (gen_server/call {:global :jobmaster} {:remove-job job-id}))


(defn+ getstate (job-id)
  "Retrieve the plist containing the information about job <job-id>."
  (gen_server/call {:global :jobmaster} {:get-job-state job-id}))


(defn+ updatestate (job-id new-state)
  "Update the plist containing the information about job <job-id> with the plist <new-state>."
  (gen_server/call {:global :jobmaster} {:update-job-state job-id new-state}))


(defn+ removestate (job-id keys)
  "Remove the keys <keys> from the state of job with id <job-id>."
  (gen_server/call {:global :jobmaster} {:remove-job-state job-id keys}))


(defn+ getjobpid (job-id)
  "Retrieve the pid of the job named <job-id>."
  (gen_server/call {:global :jobmaster} {:get-job-pid job-id}))


(defn+ listjobs ()
  "List all jobs currently indexed by the jobmaster."
  (gen_server/call {:global :jobmaster} :list-jobs))


(defn+ livejobs()
  "List all currently running jobs."
  (gen_server/call {:global :jobmaster} :live-jobs))


(defn+ submitjob (uuid mod args)
  "Submits a job by executing <mod>/submit with args <args>.
   Returns the job id (a uuid)."
  (gen_server/call {:global :jobmaster} {:submit-job uuid mod args}))


(defn+ killjob (uuid)
  "Kill the job <uuid> if it still running.  Job is not removed from the jobmaster lists."
  (gen_server/call {:global :jobmaster} {:kill-job uuid}))


;; gen_server callbacks

(defn+ init (args)
  (let ({_tbl _live-jobs log-f} args)
    {:ok {(ets/new :jmtbl []) [] log-f}}))


;; The job-dict contains entries {job-pid job-state}
(defn+ handle_call (request from state)
  (let ({job-table live-jobs log-f} state)
    (case request
      ; add a new job to the pool
      ({:add-job job-id job-pid}
        (ets/insert job-table {job-id job-pid []})
        {:reply :ok state})
      ; remove the job job-id from the pool
      ({:remove-job job-id}
        (ets/delete job-table job-id)
        {:reply :ok {job-table (lists/delete job-id live-jobs) log-f}})
      ; retrieve the entire job state for job job-id
      ({:get-job-state uuid}
        (try* 
          {:reply (ets/lookup-element job-table uuid 3) state}
          (catch (type bdy)
            {:reply :no-such-job state})))
      ; retrieve the job pid for job job-id
      ({:get-job-pid job-id}
        (try*
          {:reply (ets/lookup-element job-table job-id 2) state}
          (catch (type bdy)
            {:reply :no-such-job state})))
      ; update the job state
      ({:update-job-state uuid new-state}
        (try*
          (let* (updated-state (plist/update-with new-state (ets/lookup-element job-table uuid 3)))
            (ets/update-element job-table uuid {3 updated-state})
            {:reply :ok state})
          (catch (type bdy)
            (do
              (log-f :error "jobmaster: error updating state for job ~p type ~p bdy ~p trace ~p~n" [uuid type bdy (erl/get-stacktrace)])
              {:reply {:error type bdy} state}))))
      ; remove some keys from the job state
      ({:remove-job-state job-id ks}
        (try*
          (let* (state (ets/lookup-element job-table job-id 3))
            (ets/update-element job-table job-id {3 (plist/remove-list ks state)})
            {:reply :ok state})
          (catch (type bdy)
            {:reply {:error type bdy} state})))
      ; submit a new/existing job (matched by uuid)
      ({:submit-job uuid mod args}
        (if (empty? live-jobs)
          (case (lists/member uuid live-jobs)
            (:true
              (log-f :info "jobmaster: job ~p already running" [uuid])
              {:reply {:ok uuid} state})
            (:false
              (let* (args2   (plist/update-with [{:job-id uuid} {:short-job-id (str/substr uuid 1 8)}] args)
                     job-pid (erl/apply mod :submit [args2]))
                (log-f :info "jobmaster: job ~p activated NOW" [uuid])
                (ets/insert job-table {uuid job-pid []})
                {:reply {:ok uuid} {job-table (uuid . live-jobs) log-f}})))
          {:reply :busy state}))
      ; notification that a job has been deactivated (from the job)
      ({:job-done uuid}
        (log-f :info "jobmaster: notified that job ~p is done" [uuid])
        {:reply :ok {job-table (lists/delete uuid live-jobs) log-f}})
      ; return a list of all jobs stored by the jobmaster
      (:list-jobs
        {:reply (ets/select job-table [{{:$1 :$2 :$3} [] [:$1]}]) state})
      ; return a list of all jobs currently running
      (:live-jobs
        {:reply live-jobs state})
      ; kill the job uuid
      ({:kill-job uuid}
        (try*
          (let ([{uuid jpid jstate}] (ets/lookup job-table uuid))
            (ets/update-element job-table uuid {3 (plist/set :stage "KILLED" jstate)})
            (log-f :info "jobmaster: killing job ~p by request, looking for queue id." [uuid])
            (erl/exit jpid :killed)
            (case (plist/get :ext-mon-pid :no-such-key jstate)
              (:no-such-key (log-f :info "jobmaster: no external job found for job ~p found" [uuid])
                            {:reply :ok {job-table (lists/delete uuid live-jobs) log-f}})
              (pid          (erl/send pid :kill)
                            (log-f :info "jobmaster: job ~p was running external process monitored by ~p, kill sent" [uuid pid])
                            {:reply :ok {job-table (lists/delete uuid live-jobs) log-f}})))
          (catch (type bdy)
            (do
              (log-f :error "jobmaster: failed to kill job ~p with exc type ~p bdy ~p stack ~p" [uuid type bdy (erl/get-stacktrace)])
              {:reply {:error type bdy} state}))))
      ; message not understood
      (other
        (logsrv/error :flash "jobmaster: message ~p not understood, fix it!" [other])
        {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

