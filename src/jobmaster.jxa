; Copyright (C) 2015 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns jobmaster
  (require utils (plist :joxify) filesys filename (configsrv :joxify) job lists (string :as str)
           (gen_server :as gsrv :joxify) (file :joxify) (timelib :as ta :joxify)
           (pgsql_manager :as dbif :joxify) (dict :joxify) (erlang :as erl :joxify)
           (io_lib :as iol) os logsrv)
  (use joxa-core utils))


(defn+ start-link ()
  "Ensure table 'jobs' is present in the database and ready. Then globally register
   the jobmaster and resubmit all jobs that did not complete yet."
  (critical-check :true (table-exists? "jobs"))
  (gsrv/start-link {:global :jobmaster} :jobmaster (dict/new) [])
  (gsrv/call {:global :jobmaster} :resubmit-live-jobs))


;; --------------------------------------------
;; public API
;; --------------------------------------------


(defn+ job-done (uuid status)
  "Notify the jobmaster that the job <uuid> is complete with status <status>."
  (gsrv/call {:global :jobmaster} {:job-done uuid status}))


(defn+ submit (uuid mod args)
  "Submits a job by executing <mod>/submit with args <args>.
   Returns the job id (a uuid)."
  (gsrv/call {:global :jobmaster} {:submit-job uuid mod args}))


(defn+ livejobs ()
  "Retrieve a list of live jobs managed by the jobmaster."
  (gsrv/call {:global :jobmaster} :livejobs))


(defn+ islive? (uuid)
  "Check if the job with id <uuid> is live."
  (gsrv/call {:global :jobmaster} {:is-live? uuid}))


(defn+ getstate (uuid)
  "Retrieve the state of the job <uuid>, assuming its live."
  (gsrv/call {:global :jobmaster} {:get-state uuid}))


(defn+ removestate (uuid keys)
  "Remove the keys <keys> from the state of job with id <uuid>."
  (gsrv/call {:global :jobmaster} {:modify-state :remove uuid keys}))


(defn+ updatestate (uuid updates)
  "Internal function to update the state of live job <uuid> with the state <new-state>."
  (gsrv/call {:global :jobmaster} {:modify-state :update uuid ({:last-updated (ta/local-time)} . updates)}))


(defn+ kill (uuid)
  "Kill the job <uuid> if it still running.
  The reason is specified as :by-request.
  Job is not removed from the jobmaster lists."
  (gsrv/call {:global :jobmaster} {:kill-job uuid :by-request}))


;; --------------------------------------------
;; internal functions
;; --------------------------------------------


;; submit a job by the jobmaster
(defn execute-job-internal (uuid mod args)
  "Execute a job inside a new process."
  (logsrv/create-log uuid)
  (erl/spawn (fn ()
    (try*
      (let* (work-dir (filename/join (configsrv/get-conf :workspace-dir) uuid))
        (!!= :ok (filesys/create-dir work-dir))
        (erl/apply mod :run [(plist/set :work-dir work-dir ({:uuid uuid} . args)) (logsrv/make-log-f uuid)])
        (job-done uuid :completed))
    (catch (type body)
      (case body
        ({:killed :by-request}
          (utils/log-info "job [~s] was killed by request." [uuid])
          (updatestate uuid [{:note "killed by request"}])
          (job-done uuid :killed))
        ({:killed with-reason}
          (utils/log-error "job [~s] was killed with reason ~p.~n" [uuid with-reason])
          (updatestate uuid [{:note (lists/flatten (iol/format "killed with reason ~p" [with-reason]))}])
          (job-done uuid :killed))
        (_
          (utils/log-error "job [~s] crashed (exception type: ~p~nbody: ~p)~nstacktrace:~n~p~n" [uuid type body (erl/get-stacktrace)])
          (updatestate uuid [{:note (lists/flatten (iol/format "crashed with exception type ~p body ~p" [type body]))}])
          (job-done uuid :failed)))))
  ; whatever happens, the log gets closed
  (logsrv/close-log uuid))))


(defn resubmit-live-job (jr)
  "Resubmits the job <jr> and updates the job record with the new pid.
   The job record is already in the jobs table, thus no updates."
  (let* (uuid   (job/uuid jr)
         module (job/module jr)
         args   (job/args jr))
    (utils/log-info "jobmaster: resubmitting live job ~p (module ~p)." [uuid module])
    (let* (pid (execute-job-internal uuid module args))
      (job/pid! jr pid))))


;; --------------------------------------------
;; gen_server callbacks
;; --------------------------------------------

(defn+ init (args)
  {:ok args})


;; the jobmaster keeps tabs on all running and ended jobs by keeping
;; track of the tuple {uuid job-pid job-state}
;;
(defn+ handle_call (request from live-jobs)
  (case request
    ; submit a new/existing job (matched by uuid)
    ({:submit-job uuid mod args}
      (case (plist/find-missing [:sim-from :forecast-length-hrs :num-nodes :ppn] args)
        ([]
          (if (dict/is-key uuid live-jobs)
            (do
              (utils/log-info "jobmaster: did not start job ~p, it is already live" [uuid])
              {:reply :ok live-jobs})
            (do
              (let* (job-pid (execute-job-internal uuid mod args)
                     start-time (ta/local-time))
                (utils/log-info "jobmaster: job ~p is going LIVE now." [uuid])
                (let* (jr (job/make uuid mod args :live job-pid start-time :null []))
                  (job/insert jr)
                  {:reply :ok (dict/store uuid jr live-jobs)})))))
        (missing-keys
          {:reply {:error {:missing-keys missing-keys}} live-jobs})))
    ; notification that a job has been deactivated (from the job)
    ({:job-done uuid completion-status}
      (utils/log-info "jobmaster: notified that job ~p is done with completion status ~p" [uuid completion-status])
      (case (dict/find uuid live-jobs)
        ({:ok jr}
          (job/update-status uuid completion-status)
          {:reply :ok (dict/erase uuid live-jobs)})
        (:error
          (utils/log-info "jobmaster: job ~p not found, skipped setting status." [uuid])
          {:reply :no-such-job live-jobs})))
    ; retrieve job state
    ({:get-state uuid}
      (case (dict/find uuid live-jobs)
        ({:ok jr} {:reply (job/state jr) live-jobs})
        (:error   {:reply :no-such-job live-jobs})))
    ; kill the job uuid
    ({:kill-job uuid with-reason}
      (case (dict/find uuid live-jobs)
        ({:ok jr}
          (let* (jpid (job/pid jr))
            (erl/send jpid {:kill with-reason})
            (utils/log-info "jobmaster: killing job ~p with reason ~p." [uuid with-reason])
            {:reply :ok live-jobs}))
        (:error
          {:reply :no-such-job live-jobs})))
    ; return the list of uuids of all running jobs
    (:livejobs
      {:reply (dict/fetch-keys live-jobs) live-jobs})
    ; check if a uuid corresponds to a live job
    ({:is-live? uuid}
      {:reply (dict/is-key uuid live-jobs) live-jobs})
    ; resubmit live jobs
    (:resubmit-live-jobs
      (let* (resubmitted-jobs (lists/map resubmit-live-job/1 (job/retrieve-live-jobs)))
        {:reply :ok (lists/foldl (fn (jr jrs) (dict/store (job/uuid jr) jr jrs)) live-jobs resubmitted-jobs)}))
    ; state modifications for a live job
    ({:modify-state how uuid arg}
      (case (dict/find uuid live-jobs)
        ({:ok jr}
          (let (state0 (job/state jr)
                state1 (case how
                         (:remove (plist/remove-list arg state0))
                         (:update (plist/update-with arg state0))))
            (job/update-state uuid state1)
            {:reply :ok (dict/store uuid (job/state! jr state1) live-jobs)}))
        (:error {:reply :no-such-job live-jobs})))
    ; message not understood
    (other
      (utils/log-error "jobmaster: message ~p not understood, fix it!" [other])
      {:reply :invalid-request live-jobs})))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

