; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns jobmaster
  (require utils plist logsrv
           lists (string :as str) gen_server filename (file :joxify)
           (dict :joxify) (erlang :as erl :joxify) (io_lib :as iol) os)
  (use joxa-core utils))


(defn+ start-link ()
  (gen_server/start_link {:global :jobmaster} :jobmaster {(dict/new) [] (logsrv/make-log-f "system")} []))

;; API

(defn+ addjob (job-id job-pid info-plist)
  "Add a job with name <job-id> and process <job-pid> and current job state plist <info-plist>."
  (gen_server/call {:global :jobmaster} {:add-job job-id job-pid info-plist}))


(defn+ deljob (job-id)
  "Remove the job named <job-id> from the master index."
  (gen_server/call {:global :jobmaster} {:remove-job job-id}))


(defn+ getstate (job-id)
  "Retrieve the plist containing the information about job <job-id>."
  (gen_server/call {:global :jobmaster} {:get-job-state job-id}))


(defn+ updatestate (job-id new-state)
  "Update the plist containing the information about job <job-id> with the plist <new-state>."
  (gen_server/call {:global :jobmaster} {:update-job-state job-id new-state}))


(defn+ removestate (job-id keys)
  "Remove the keys <keys> from the state of job with id <job-id>."
  (gen_server/call {:global :jobmaster} {:remove-job-state job-id keys}))


(defn+ getjobpid (job-id)
  "Retrieve the pid of the job named <job-id>."
  (gen_server/call {:global :jobmaster} {:job-pid job-id}))


(defn+ listjobs ()
  "List all jobs currently indexed by the jobmaster."
  (gen_server/call {:global :jobmaster} :list-jobs))


(defn+ livejobs()
  "List all currently running jobs."
  (gen_server/call {:global :jobmaster} :live-jobs))


(defn+ submitjob (mod args)
  "Submits a job by executing <mod>/submit with args <args>.
   Returns the job id (a uuid)."
  (gen_server/call {:global :jobmaster} {:submit-job mod args}))


(defn+ resubmitjob (uuid mod args)
  "Resubmit a job executed by module <mod> with arguments <args> and with the given <uuid>."
  (gen_server/call {:global :jobmaster} {:resubmit-job uuid mod args}))


(defn+ killjob (uuid)
  "Kill the job <uuid> if it still running.  Job is not removed from the jobmaster lists."
  (gen_server/call {:global :jobmaster} {:kill-job uuid}))


;; Internal funcrions

(defn kill-job (uuid jpid)
  "The jobmaster will kill any external queued/running process that is registered as :qid in the job state."
  (erl/exit jpid :kill)
  (updatestate uuid [:stage "KILLED"])
  (let* (info-plist (getstate uuid))
    (case (plist/get :qid :no-such-key uuid)
      (:no-such-key :ok)
      (qid (os/cmd (iol/format "qdel ~p" [qid]))))))

;; gen_server callbacks

(defn+ init (args)
    {:ok args})

;; The job-dict contains entries {job-pid job-state}
(defn+ handle_call (request from state)
  (let ({job-dict live-jobs log-f} state)
   (case request
    ({:add-job job-id job-pid job-state}
      {:reply :ok {(dict/store job-id {job-pid job-state} job-dict) live-jobs log-f}})
    ({:remove-job job-id}
      ; here a termination must be started
      {:reply :ok {(dict/erase job-id job-dict) live-jobs log-f}})
    ({:get-job-state job-id}
      (case (dict/find job-id job-dict)
        ({:ok {job-pid job-state}} {:reply job-state state})
        (:error                    {:reply :no-such-job state})))
    ({:update-job-state job-id new-state}
      (case (dict/find job-id job-dict)
        ({:ok {job-pid job-state}}
          {:reply :ok {(dict/store job-id {job-pid (plist/update-with new-state job-state)} job-dict) live-jobs log-f}})
        (:error
          {:reply :no-such-job state})))
    ({:remove-job-state job-id ks}
      (case (dict/find job-id job-dict)
        ({:ok {job-pid job-state}}
          {:reply :ok {(dict/store job-id {job-pid (plist/remove-list ks job-state)} job-dict) live-jobs log-f}})
        (:error
          {:reply :no-such-job state})))
    ({:job-pid job-id}
      (case (dict/find job-id job-dict)
        ({:ok {job-pid job-state}} {:reply job-pid state})
        (:error                    {:reply :no-such-job state})))
    (:list-jobs
      {:reply (dict/fetch-keys job-dict) state})
    ({:submit-job mod args}
      (if (empty? live-jobs)
        (let* (uuid       (utils/make-uuid)
               short-uuid (str/substr uuid 1 8)
               args2      (plist/update-with [{:job-id uuid} {:short-job-id short-uuid}] args)
               job-pid    (erl/apply mod :submit [args2]))
          (log-f :info "jobmaster: job ~p activated" [uuid])
          {:reply {:ok uuid} {(dict/store uuid {job-pid []} job-dict) (uuid . live-jobs) log-f}})
        {:reply :busy state}))
    ({:resubmit-job uuid mod args}
      (let* (short-uuid (str/substr uuid 1 8)
             args2      (plist/update-with [{:job-id uuid} {:short-job-id short-uuid}] args)
             job-pid    (erl/apply mod :submit [args2])
             act-jobs2  (if (lists/member uuid live-jobs) live-jobs (uuid . live-jobs)))
        (log-f :info "jobmaster: job ~p resubmitted (and activated)" [uuid])
        {:reply {:ok uuid} {(dict/store uuid {job-pid []} job-dict) act-jobs2 log-f}}))
    ({:job-deactivated uuid}
      (log-f :info "jobmaster: job ~p done" [uuid])
      {:reply :ok {job-dict (lists/delete uuid live-jobs) log-f}})
    (:live-jobs
      {:reply live-jobs state})
    ({:kill-job uuid}
      (case (dict/find uuid job-dict)
        ({:ok {jpid info-plist}}
          (log-f :info "jobmaster: job ~p killed by request." [uuid])
          (erl/spawn (fn () (kill-job uuid jpid)))
          {:reply :job-killed {job-dict (lists/delete uuid live-jobs) log-f}})
        (:error
          {:reply :no-such-job state})))
    (other
      (logsrv/error :flash "jobmaster: message ~p not understood, fix it!" [other])
      {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

