(ns grib-def
    (use joxa-records))

; name - an identifier of the grib definition
; runs - list of hours when runs are started, e.g. [0 12]
; delay - no. of hours it takes for the files to be availble for d/l after run start
; url-prefix - the fixed part of the URL for file retrieval
; name-fun   - a function that accepts cycle time (erlang datetime) and file index (integer) and returns
;              the second part of the download URL
; vtable-file - the VTABLE file that should be used to process the GRIB files from this source
; domain - the storage domain
; file-hours - a list of hours (from run time) for which grib files are available
; nl-keys - the namelist keys that must be inserted into WPS namelist to correctly handle the GRIB data
(defrecord+ name runs delay url-prefix name-fun vtable-file domain file-hours nl-keys)


(ns grib-retr
    (require (erlang 'as erl)
	     httpc
	     inets
	     grib-def
	     lists
	     (io_lib :as iol)
	     (joxa-lists :as jxl)
	     (joxa-core :as jxc)
	     (grib-time :as gtm)
	     string))



(defn+ start ()
  (inets/start))


(defn+ get-cycle-at (datetime delay runs)
  "Retrieve most recent cycle that can provide GRIB source data for the given timestamp."
    (jxc/let ({date {h _m _s}} (gtm/shift-by-hours datetime (jxc/- delay)))
      (case (lists/foldl (fn (x a) (jxc/if (jxc/gte h x) x a)) :undefined runs)
	    ; if all of the runs on the same day are after our request, try again with
	    ; datetime an hour before
	    (:undefined (get-cycle-at (gtm/shift-by-hours datetime -1) delay runs))
	    (last-cycle-hr {date {last-cycle-hr 0 0}}))))


(defn+ move-cycle (run-ndx run-len by)
  "Shift a run <run-ndx> left or right by <by> element steps.  Returns a new cycle
   run hour and a day shift (left or right). <by> \in \{ +1, -1\}."
  (let* (new-run (jxc/+ run-ndx by))
    (case new-run
	  (nr (when (jxc/lte new-run 0)) {(jxc/+ new-run run-len) -1})
	  (nr (when (erl/> new-run run-len)) {(jxc/- new-run run-len) 1})
	  (nr {nr 0}))))
		   

(defn sign (val)
  "Return sign of number, 0 -> 0, x < 0 -> -1, x > 0 -> 1."
  (case val
	(0 0)
	(v (jxc/if (erl/> v 0) 1 -1))))


(defn+ shift-cycle-by (cycle run-ndx run-len runs delta)
  "Shift the cycle <cycle> at the run ndx <run-ndx> of the day <delta> cycles into the future
   (if <delta> is positive) or into the past (<delta> is negative)."
  (case delta
	(0 cycle)
	(d (let* (step (erl/- (sign delta)))
	     (jxc/let ({new-ndx day-delta} (move-cycle run-ndx run-len step))
	       (shift-cycle-by (gtm/shift-by-days (gtm/set-hour cycle (lists/nth new-ndx runs)) day-delta)
			      new-ndx run-len runs (erl/+ delta step)))))))


(defn+ shift-cycle-by (cycle delta grib-src)
  "Find a cycle <delta> steps into the past if <delta> is negative or into the future if <delta> is positive.
   The function requires the run scheduling per day contained in the <grib-src> info structure."
  (jxc/let ({_date, {h _m _s}} cycle)
   (let* (runs (grib-def/runs grib-src)
          run-ndx (string/chr runs h)
	  run-len (erl/length runs))
     (shift-cycle-by cycle run-ndx run-len runs delta))))
 

(defn+ cull-cycle (c by-c)
  "Ensure cycle <c> is not later than cycle <by-c>"
  (jxc/if (erl/> c by-c) by-c c))

(defn+ forecast-hour (h grib-src)
  "Returns the highest file hour that is smaller than <h> for grib source <grib-src>."
  (case (lists/dropwhile (fn (x) (erl/< x h)) (grib-def/file-hours grib-src))
        ([] :beyond-end)
	(rest (jxl/hd rest))))


(defn build-file-list (now to-adj latest-cycle cov-from cov-to last-ref grib-src files)
  "Build a file list recursively covering the period from <now> to <to-adj>."
  (case (erl/> to-adj cov-to)
   (:true
    (let* (next-now (gtm/shift-by-hours now 1)
	   cycle (cull-cycle (get-cycle-at now 0 (grib-def/runs grib-src)) latest-cycle)
	   fc-hr (forecast-hour (gtm/hours-between cycle now) grib-src))
;      (io/format "now ~p cycle ~p fc-hr ~p~n" [now cycle fc-hr])
      (case {cycle fc-hr}
	    ({_ :beyond-end} :out-of-range)
	    (last-ref (build-file-list next-now to-adj latest-cycle cov-from cov-to last-ref grib-src files))
	    (new-last-ref
	     ; we have a new file reference that must be appended to the file list
	     (let* (new-file (lists/flatten ((grib-def/name-fun grib-src) cycle fc-hr))
		    new-time (gtm/shift-by-hours cycle fc-hr))
	       (build-file-list next-now to-adj latest-cycle 
				(gtm/min-time cov-from new-time)
				(gtm/max-time cov-to new-time)
				new-last-ref grib-src (new-file . files)))))))
   (:false
    {cov-from cov-to files})))
	 
  

(defn+ compute-manifest (from to grib-src at-time delta)
  "Compute files to be downloaded from source <grib-src> that cover a time span
   between <from> and <to> (inclusive) as available at time <at-time>, also skip
   <delta> last cycles - this can be used to prevent use of a possibly incomplete
   cycle."
  (let* (cycle-at-time (get-cycle-at at-time (grib-def/delay grib-src) (grib-def/runs grib-src))
	 latest-avail-cycle (shift-cycle-by cycle-at-time delta grib-src)
	 from-adj (gtm/round-hours from :down)
	 to-adj (gtm/round-hours to :up))
    (build-file-list from-adj to-adj latest-avail-cycle 
		     from-adj (gtm/shift-by-hours from-adj -1) :undefined grib-src [])))
	 


(defn+ def-src ()
  (grib-def/make "nam_218"  ; id
		 [0 6 12 18]  ; runs
		 2 ;delay [hrs]
		 "http://nomads.ncep.noaa.gov/pub/data/nccf/com/nam/prod/"  ; the (fixed) URL prefix
		 (fn (cyc fc-hr) 
		     (jxc/let ({{y m d} {hr _m _s}} cyc)
			      (iol/format "nam.~4..0B~2..0B~2..0B/nam.t~2..0Bz.awphys~2..0B.grb2.tm00"
					     [y m d hr fc-hr])))   ; the name construction function
		 "ungrib/Variable_Tables/Vtable.NAM"  ; vtable file consistent with GRIB info
		 "nam_218"  ; the name of the storage domain
		 (lists/flatten [(lists/seq 0 36) (lists/map (fn (x) (erl/* x 3)) (lists/seq 13 28))]) ; forecast hours
		 [{"num_metgrid_levels", [40]}]))
		 
		 

