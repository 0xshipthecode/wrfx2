(ns grib-def
    (use joxa-records))

; name - an identifier of the grib definition
; runs - list of hours when runs are started, e.g. [0 12]
; delay - no. of hours it takes for the files to be availble for d/l after run start
; url-prefix - the fixed part of the URL for file retrieval
; name-fun   - a function that accepts cycle time (erlang datetime) and file index (integer) and returns
;              the second part of the download URL
; vtable-file - the VTABLE file that should be used to process the GRIB files from this source
; domain - the storage domain
; file-hours - a list of hours (from run time) for which grib files are available
; max-downloads - the maximum number of concurrent downloads to use with the GRIB source
; nl-keys - the namelist keys that must be inserted into WPS namelist to correctly handle the GRIB data
(defrecord+ name runs delay url-prefix name-fun vtable-file domain file-hours max-downloads nl-keys)


(ns grib-retr
    (require (erlang 'as erl)
	     httpc
	     inets
	     grib-def
	     lists
	     timer
	     (filelib :joxify)
	     (io_lib :as iol)
	     (joxa-lists :as jxl)
	     (joxa-core :as jxc)
	     (time-arith :as tma)
	     msglog
	     string)
    (use math-utils))


(defn get-cycle-at (datetime delay runs)
  "Retrieve most recent cycle that can provide GRIB source data for the given timestamp."
    (jxc/let ({date {h _m _s}} (tma/shift-by-hours datetime (jxc/- delay)))
      (case (lists/foldl (fn (x a) (jxc/if (jxc/gte h x) x a)) :undefined runs)
	    ; if all of the runs on the same day are after our request, try again with
	    ; datetime an hour before
	    (:undefined (get-cycle-at (tma/shift-by-hours datetime -1) delay runs))
	    (last-cycle-hr {date {last-cycle-hr 0 0}}))))


(defn+ move-cycle (run-ndx run-len by)
  "Shift a run <run-ndx> left or right by <by> element steps.  Returns a new cycle
   run hour and a day shift (left or right). <by> \in \{ +1, -1\}."
  (let* (new-run (jxc/+ run-ndx by))
    (case new-run
	  (nr (when (jxc/lte new-run 0)) {(jxc/+ new-run run-len) -1})
	  (nr (when (erl/> new-run run-len)) {(jxc/- new-run run-len) 1})
	  (nr {nr 0}))))
		   

(defn shift-cycle-by (cycle run-ndx run-len runs delta)
  "Shift the cycle <cycle> at the run ndx <run-ndx> of the day <delta> cycles into the future
   (if <delta> is positive) or into the past (<delta> is negative)."
  (case delta
	(0 cycle)
	(d (let* (step (erl/- (sign delta)))
	     (jxc/let ({new-ndx day-delta} (move-cycle run-ndx run-len step))
	       (shift-cycle-by (tma/shift-by-days (tma/set-hour cycle (lists/nth new-ndx runs)) day-delta)
			      new-ndx run-len runs (erl/+ delta step)))))))


(defn shift-cycle-by (cycle delta grib-src)
  "Find a cycle <delta> steps into the past if <delta> is negative or into the future if <delta> is positive.
   The function requires the run scheduling per day contained in the <grib-src> info structure."
  (jxc/let ({_date, {h _m _s}} cycle)
   (let* (runs (grib-def/runs grib-src)
          run-ndx (string/chr runs h)
	  run-len (erl/length runs))
     (shift-cycle-by cycle run-ndx run-len runs delta))))
 

(defn cull-cycle (c by-c)
  "Ensure cycle <c> is not later than cycle <by-c>."
  (jxc/if (erl/> c by-c) by-c c))

(defn forecast-hour (h grib-src)
  "Returns the highest file hour that is smaller than <h> for grib source <grib-src>."
  (case (lists/dropwhile (fn (x) (erl/< x h)) (grib-def/file-hours grib-src))
        ([] :beyond-end)
	(rest (jxl/hd rest))))


(defn build-file-list (now to-adj latest-cycle cov-from cov-to last-ref grib-src files)
  "Build a file list recursively covering the period from <now> to <to-adj>."
  (case (erl/> to-adj cov-to)
   (:true
    (let* (next-now (tma/shift-by-hours now 1)
	   cycle (cull-cycle (get-cycle-at now 0 (grib-def/runs grib-src)) latest-cycle)
	   fc-hr (forecast-hour (tma/hours-between cycle now) grib-src))
      (case {cycle fc-hr}
	    ({_ :beyond-end} :out-of-range)
	    ; the reference is the same as the last reference, no changes in list, move to next forecast hour
	    (last-ref (build-file-list next-now to-adj latest-cycle cov-from cov-to last-ref grib-src files))
	    (new-last-ref
	     ; we have a new file reference that must be appended to the file list
	     (let* (new-file (lists/flatten ((grib-def/name-fun grib-src) cycle fc-hr))
		    new-time (tma/shift-by-hours cycle fc-hr))
	       (build-file-list next-now to-adj latest-cycle 
				(tma/min-time cov-from new-time)
				(tma/max-time cov-to new-time)
				new-last-ref grib-src (new-file . files)))))))
   (:false
    {cov-from cov-to files})))
  

(defn+ compute-manifest (from to at-time delta grib-src)
  "Compute files to be downloaded from source <grib-src> that cover a time span
   between <from> and <to> (inclusive) as available at time <at-time>, also skip
   <delta> last cycles - this can be used to prevent use of a possibly incomplete
   cycle."
  (let* (cycle-at-time (get-cycle-at at-time (grib-def/delay grib-src) (grib-def/runs grib-src))
	 latest-avail-cycle (shift-cycle-by cycle-at-time delta grib-src)
	 from-adj (tma/round-hours from :down)
	 to-adj (tma/round-hours to :up))
    (build-file-list from-adj to-adj latest-avail-cycle 
		     from-adj (tma/shift-by-hours from-adj -1) :undefined grib-src [])))


(defn stream-file (target ident storage-dir grib-src)
  "Stream the content <ident> prefixed with grib-src/url-prefix to disk to file <storage-dir>/<ident>."
  (let* (url (lists/flatten [(grib-def/url-prefix grib-src) "/" ident])
	 abs-path (lists/flatten [storage-dir "/" (grib-def/domain grib-src) "/" ident]))
    (filelib/ensure-dir abs-path)
    (case (httpc/request :get {url []} [] [{:stream, abs-path}])
	  ({:ok, :saved_to_file} (erl/send target :download-complete))
	  (_ (erl/send target {:download-fail ident})))))



;(defspec await-next-result ((erl/list) (erl/integer) (erl/list) (erl/tuple)) (erl/any))

(defn download-grib-files (manifest curr-dl storage-dir grib-src)
  "Download the grib files on the manifest in parallel.
   Returns either :success or {:failure url}"
  (let* (myself (erl/self)
	 max-dl (grib-def/max-downloads grib-src)
	 await-next-result (fn (manifest curr-dl storage-dir grib-src)
			       (receive
				(:download-complete
				 (download-grib-files manifest (jxc/decr curr-dl) storage-dir grib-src))
				({:download-fail what}
				 {:failed-download what}))))
    (case manifest
	  ([]
	   (jxc/if (zero? curr-dl)
		   :success
		   (await-next-result manifest curr-dl storage-dir grib-src)))
	  ((next . rest)
	   (jxc/if (erl/< curr-dl max-dl)
		   (do
		    (erl/spawn (fn () (stream-file myself next storage-dir grib-src)))
		    (download-grib-files rest (jxc/incr curr-dl) storage-dir grib-src))
		   (await-next-result manifest curr-dl storage-dir grib-src))))))


(defn+ download-gribs (manifest stor-dir grib-src)
  "Download a <manifest> of grib files in parallel with <max-concurrent-dl> parallel downloads.from source <grib-src>."
  (download-grib-files manifest 0 stor-dir grib-src))


(defn url-exists? (url)
  "Checks if a URL exists."
  (io/format "checking existence of ~p~n" [url])
  (case (httpc/request :head {url []} [] [])
	({:ok {{_ 200 _} _ _}} :true)
	(_notok :false)))


(defn+ find-unreachable-gribs (manifest grib-src)
  "Returns a list of GRIB files missing on the server side from the list <manifest>."
  (let* (prefix (grib-def/url-prefix grib-src))
    (lists/filter (fn (f) (erl/not (url-exists? (lists/flatten [prefix "/" f])))) manifest)))


(defn+ is-grib-local? (ident stor-dir grib-src)
  "Check if a GRIB file identified by <ident> from source <grib-src> is cached locally in <stor-dir>."
  (let* (abs-path (lists/flatten [stor-dir "/" (grib-def/domain grib-src) "/" ident]))
    (filelib/is-regular abs-path)))


(defn+ remove-local-gribs (manifest stor-dir grib-src)
  "Remove GRIB files from manifest that are already available locally."
  (lists/filter (fn (x) (erl/not (is-grib-local? x stor-dir grib-src))) manifest))


(defn+ retrieve-gribs (from to at-time delta stor-dir grib-src log-func)
  "Computes the GRIB files needed for the simulation covering the time interval <from> to <to>
   which use <delta> cycles before the last cycle and downloads them from the grib source <grib-src>.
   Files already available in <stor-dir> are not redownloaded.
   Returns one of {:success {cov-from cov-to manifest}},
                  :out-of-range,
                  {:missing-gribs list-of-gribs}
                  {:failed-download url}."
  (log-func :info ["grib-retr (~p) -> have request with from ~p to ~p at-time ~p delta ~p stor-dir ~p"
	    (grib-def/name grib-src) from to at-time delta stor-dir])
  (case (compute-manifest from to at-time delta grib-src)
	({cov-from cov-to manifest}
	 (log-func :info ["grib-retr (~p) -> manifest has ~p files covering from ~p to ~p"
		   (grib-def/name grib-src) (erl/length manifest) cov-from cov-to])
	 (io/format "manifest is ~p~n" [manifest])
	 (let* (gribs-to-dl (remove-local-gribs manifest stor-dir grib-src))
	   (case (find-unreachable-gribs gribs-to-dl grib-src)
		 ; if no gribs missing, use this source
		 ([] 
		  (log-func :info ["grib-retr (~p) -> downloading ~p files now"
			    (grib-def/name grib-src) (erl/length gribs-to-dl)])
		  (case (download-gribs gribs-to-dl stor-dir grib-src)
			   (:success {:success {cov-from cov-to manifest}})
			   (failure failure)))
		 ; in case of missing gribs, download
		 (missing-gribs 
		  (log-func :warn ["grib-retr (~p) -> source cannot satisfy request, have ~p missing gribs."
			    (grib-def/name grib-src) (erl/length missing-gribs)])
		  {:missing-gribs missing-gribs}))))
	  ; could not even compute the manifest
	(:out-of-range
	 (log-func :warn ["grib-retr (~p) -> cannot find GRIB files to satisfy the request from ~p to ~p"
		   (grib-def/name grib-src) from to])
	 :out-of-range)))
