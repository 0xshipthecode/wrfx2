(ns grib-def
    (use joxa-records))

; name - an identifier of the grib definition
; runs - list of hours when runs are started, e.g. [0 12]
; delay - no. of hours it takes for the files to be availble for d/l after run start
; url-prefix - the fixed part of the URL for file retrieval
; name-fun   - a function that accepts cycle time (erlang datetime) and file index (integer) and returns
;              the second part of the download URL
; vtable-file - the VTABLE file that should be used to process the GRIB files from this source
; domain - the storage domain
; file-hours - a list of hours (from run time) for which grib files are available
; max-downloads - the maximum number of concurrent downloads to use with the GRIB source
; nl-keys - the namelist keys that must be inserted into WPS namelist to correctly handle the GRIB data
(defrecord+ name runs delay url-prefix name-fun vtable-file domain file-hours max-downloads nl-keys)


(ns grib-retr
    (require (erlang 'as erl)
	     httpc
	     inets
	     grib-def
	     lists
	     timer
	     (filelib :joxify)
	     (io_lib :as iol)
	     (joxa-lists :as jxl)
	     (joxa-core :as jxc)
	     (grib-time :as gtm)
	     string)
    (use utils))


(defn get-cycle-at (datetime delay runs)
  "Retrieve most recent cycle that can provide GRIB source data for the given timestamp."
    (jxc/let ({date {h _m _s}} (gtm/shift-by-hours datetime (jxc/- delay)))
      (case (lists/foldl (fn (x a) (jxc/if (jxc/gte h x) x a)) :undefined runs)
	    ; if all of the runs on the same day are after our request, try again with
	    ; datetime an hour before
	    (:undefined (get-cycle-at (gtm/shift-by-hours datetime -1) delay runs))
	    (last-cycle-hr {date {last-cycle-hr 0 0}}))))


(defn+ move-cycle (run-ndx run-len by)
  "Shift a run <run-ndx> left or right by <by> element steps.  Returns a new cycle
   run hour and a day shift (left or right). <by> \in \{ +1, -1\}."
  (let* (new-run (jxc/+ run-ndx by))
    (case new-run
	  (nr (when (jxc/lte new-run 0)) {(jxc/+ new-run run-len) -1})
	  (nr (when (erl/> new-run run-len)) {(jxc/- new-run run-len) 1})
	  (nr {nr 0}))))
		   

(defn shift-cycle-by (cycle run-ndx run-len runs delta)
  "Shift the cycle <cycle> at the run ndx <run-ndx> of the day <delta> cycles into the future
   (if <delta> is positive) or into the past (<delta> is negative)."
  (case delta
	(0 cycle)
	(d (let* (step (erl/- (sign delta)))
	     (jxc/let ({new-ndx day-delta} (move-cycle run-ndx run-len step))
	       (shift-cycle-by (gtm/shift-by-days (gtm/set-hour cycle (lists/nth new-ndx runs)) day-delta)
			      new-ndx run-len runs (erl/+ delta step)))))))


(defn shift-cycle-by (cycle delta grib-src)
  "Find a cycle <delta> steps into the past if <delta> is negative or into the future if <delta> is positive.
   The function requires the run scheduling per day contained in the <grib-src> info structure."
  (jxc/let ({_date, {h _m _s}} cycle)
   (let* (runs (grib-def/runs grib-src)
          run-ndx (string/chr runs h)
	  run-len (erl/length runs))
     (shift-cycle-by cycle run-ndx run-len runs delta))))
 

(defn cull-cycle (c by-c)
  "Ensure cycle <c> is not later than cycle <by-c>"
  (jxc/if (erl/> c by-c) by-c c))

(defn forecast-hour (h grib-src)
  "Returns the highest file hour that is smaller than <h> for grib source <grib-src>."
  (case (lists/dropwhile (fn (x) (erl/< x h)) (grib-def/file-hours grib-src))
        ([] :beyond-end)
	(rest (jxl/hd rest))))


(defn build-file-list (now to-adj latest-cycle cov-from cov-to last-ref grib-src files)
  "Build a file list recursively covering the period from <now> to <to-adj>."
  (case (erl/> to-adj cov-to)
   (:true
    (let* (next-now (gtm/shift-by-hours now 1)
	   cycle (cull-cycle (get-cycle-at now 0 (grib-def/runs grib-src)) latest-cycle)
	   fc-hr (forecast-hour (gtm/hours-between cycle now) grib-src))
      (case {cycle fc-hr}
	    ({_ :beyond-end} :out-of-range)
	    ; the reference is the same as the last reference, no changes in list, move to next forecast hour
	    (last-ref (build-file-list next-now to-adj latest-cycle cov-from cov-to last-ref grib-src files))
	    (new-last-ref
	     ; we have a new file reference that must be appended to the file list
	     (let* (new-file (lists/flatten ((grib-def/name-fun grib-src) cycle fc-hr))
		    new-time (gtm/shift-by-hours cycle fc-hr))
	       (build-file-list next-now to-adj latest-cycle 
				(gtm/min-time cov-from new-time)
				(gtm/max-time cov-to new-time)
				new-last-ref grib-src (new-file . files)))))))
   (:false
    {cov-from cov-to files})))
  

(defn+ compute-manifest (from to at-time delta grib-src)
  "Compute files to be downloaded from source <grib-src> that cover a time span
   between <from> and <to> (inclusive) as available at time <at-time>, also skip
   <delta> last cycles - this can be used to prevent use of a possibly incomplete
   cycle."
  (let* (cycle-at-time (get-cycle-at at-time (grib-def/delay grib-src) (grib-def/runs grib-src))
	 latest-avail-cycle (shift-cycle-by cycle-at-time delta grib-src)
	 from-adj (gtm/round-hours from :down)
	 to-adj (gtm/round-hours to :up))
    (build-file-list from-adj to-adj latest-avail-cycle 
		     from-adj (gtm/shift-by-hours from-adj -1) :undefined grib-src [])))


(defn stream-file (target ident storage-dir grib-src)
  "Stream the content <ident> prefixed with grib-src/url-prefix to disk to file <storage-dir>/<ident>."
  (let* (url (lists/flatten [(grib-def/url-prefix grib-src) "/" ident])
	 abs-path (lists/flatten [storage-dir "/" (grib-def/domain grib-src) "/" ident]))
    (filelib/ensure-dir abs-path)
    (case (httpc/request :get {url []} [] [{:stream, abs-path}])
	  ({:ok, :saved_to_file} (erl/send target :download-complete))
	  (_ (erl/send target {:download-fail ident})))))


(defn download-grib-files (manifest curr-dl storage-dir grib-src)
  "Download the grib files on the manifest in parallel.
   Returns either :success or {:failure url}"
  (let* (myself (erl/self)
	 max-dl (grib-def/max-downloads grib-src))
    (case manifest
	  ([]
	   (jxc/if (erl/== curr-dl 0) :success
		   (receive
		    (:download-complete (download-grib-files [] (jxc/decr curr-dl) storage-dir grib-src))
		    ({:download-fail what} {:failed-download what}))))
	  ((next . rest)
	   (case curr-dl
		 (max-dl
		  (receive
		   (:download-complete (download-grib-files manifest (jxc/decr curr-dl) storage-dir grib-src))
		   ({:download-fail what} {:failed-download what})))
		 (_
		  (io/format "spawning new download for ~p~n" [next])
		  (erl/spawn (fn () (stream-file myself next storage-dir grib-src)))
		  (download-grib-files rest (jxc/incr curr-dl) storage-dir grib-src)))))))


(defn+ download-gribs (manifest stor-dir grib-src)
  "Download a <manifest> of grib files in parallel with <max-concurrent-dl> parallel downloads.from source <grib-src>."
  (download-grib-files manifest 0 stor-dir grib-src))


(defn url-exists? (url)
  "Checks if a URL exists."
  (io/format "checking existence of ~p~n" [url])
  (case (httpc/request :head {url []} [] [])
	({:ok {{_ 200 _} _ _}} :true)
	(_notok :false)))


(defn+ find-unreachable-gribs (manifest grib-src)
  "Returns a list of GRIB files missing on the server side from the list <manifest>."
  (let* (prefix (grib-def/url-prefix grib-src))
    (lists/filter (fn (f) (erl/not (url-exists? (lists/flatten [prefix "/" f])))) manifest)))


(defn+ is-grib-local? (ident stor-dir grib-src)
  "Check if a GRIB file identified by <ident> from source <grib-src> is cached locally in <stor-dir>."
  (let* (abs-path (lists/flatten [stor-dir "/" (grib-def/domain grib-src) "/" ident]))
    (filelib/is-regular abs-path)))


(defn+ remove-local-gribs (manifest stor-dir grib-src)
  "Remove GRIB files from manifest that are already available locally."
  (lists/filter (fn (x) (erl/not (is-grib-local? x stor-dir grib-src))) manifest))


(defn+ def-src ()
  "Construct a tuple describing the nam_218 grid source on the NOAA nomads server."
  (grib-def/make "nam_218"  ; id
		 [0 6 12 18]  ; runs
		 2 ;delay [hrs]
		 "http://nomads.ncep.noaa.gov/pub/data/nccf/com/nam/prod"  ; the URL prefix
		 (fn (cyc fc-hr)
		     (jxc/let ({{y m d} {hr _m _s}} cyc)
			      (iol/format "nam.~4..0B~2..0B~2..0B/nam.t~2..0Bz.awphys~2..0B.grb2.tm00"
					     [y m d hr fc-hr])))   ; the name construction function
		 "ungrib/Variable_Tables/Vtable.NAM"  ; vtable file consistent with GRIB info
		 "nam_218"  ; the name of the storage domain
		 (lists/flatten [(lists/seq 0 36) (lists/map (fn (x) (erl/* x 3)) (lists/seq 13 28))]) ; forecast hours
		 1 ; max concurrent downloads
		 [{"num_metgrid_levels", [40]}]))
		 

(defn+ retrieve-gribs (from to at-time delta stor-dir grib-src)
  "Computes the GRIB files needed for the simulation covering the time interval <from> to <to>
   which use <delta> cycles before the last cycle and downloads them from the grib source <grib-src>.
   Files already available in <stor-dir> are not redownloaded.
   Returns either :success, :out-of-range, {:missing-gribs list-of-gribs} or {:failed-download url}."
  (case (compute-manifest from to at-time delta grib-src)
	({cov-from cov-to manifest}
	 (let* (gribs-to-dl (remove-local-gribs manifest stor-dir grib-src))
	   (case (find-unreachable-gribs gribs-to-dl grib-src)
		 ; if no gribs missing, use this source
		 ([] (download-gribs gribs-to-dl stor-dir grib-src))
		 ; in case of missing gribs, download
		 (missing-gribs {:missing-gribs missing-gribs}))))
	  ; could not even compute the manifest
	(:out-of-range :out-of-range)))
