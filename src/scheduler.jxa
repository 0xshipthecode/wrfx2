; Copyright (C) 2013-2014 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns schedule
  (require (joxa-core :as jxc) (erlang :as erl :joxify) utils (pgsql_manager :as dbif :joxify))
  (use joxa-records))

(defrecord+ job-name job-start-time module function args)


(defn sql-to-schedule (sql-data)
  "Convert the SQL representation of the schedule to the schedule record."
  (jxc/let ({job-name job-start-time module-str function-str args-str} sql-data)
    (make job-name job-start-time (erl/list-to-atom module-str)
          (erl/list-to-atom function-str) (utils/string-to-term args-str))))


(defn+ load ()
  "Load all entries in the schedule and return them as schedule records."
  (case (dbif/simple-query "select (job_name, start_time, args) from schedule")
    ({{:select _} lst} (lists/map sql-to-schedule/1 lst))))


(ns scheduler
  (require (pgsql_manager :as dbif :joxify) lists (gen_server :as gsrv :joxify) (timelib :as ta :joxify)
           (erlang :as erl :joxify) schedule io (io_lib :as iol) (file :joxify))
  (use joxa-core utils))


(defn+ reload-schedule ()
  "Send a request to the scheduler to reload the schedule."
  (gsrv/call :scheduler :reload-schedule 5000))


(defn+ start-link ()
  ;(critical-check :true (table-exists? "schedule"))
  (!!= {:ok _} (gsrv/start-link {:local :scheduler} :scheduler [(ta/local-time) [] []] []))
  (log-info "scheduler: pre-init ok, loading schedules now" [])
  (!!= :ok (reload-schedule))
  (log-info "scheduler: schedule loaded successfully" []))


;; internal API

(defn sort-jobs (job-list)
  (lists/sort (fn (x y) (erl/< (schedule/job-start-time x) (schedule/job-start-time y))) job-list))


(defn start-jobs (last-ts now-ts jobs-past jobs-todo)
  (let ({last-day last-time} last-ts
        {day-now  time-now}  now-ts)
    (case day-now
      (last-day
      ; we are still on the same day, go through jobs-todo list and check if we need to run something
        (case jobs-todo
          ([] {jobs-past []})
          ((job . jobs-todo-rest)
            (schedule/let job (job-name job-name job-start-time ts module mod function func args args)
              (if (erl/and (lte ts time-now) (gte ts last-time))
                (do
                  (log-info "scheduler: starting job ~p at ~w, start time was ~w." [job-name {day-now time-now} ts])
                  (erl/spawn (fn ()
                    (try*
                      (erl/apply mod func args)
                    (catch (type bdy)
                      (log-error "scheduler: job function of job ~p threw exception type ~w body ~w~nstacktrace ~p"
                             [job-name type bdy (erl/get-stacktrace)])))))
                  (start-jobs last-ts now-ts (job . jobs-past) jobs-todo-rest))
                ; since jobs are sorted by time, if this job didn't bite neither will any other
                ; this assumes no jobs slips through the cracks (if a job didn't run and job-start < last-time
                ; but under no circumstances is that supposed to happen)
                {jobs-past jobs-todo})))))
      (new-day
        ; we have rolled over midnight, move all jobs started to jobs that need to be run
        ; make sure (by another invocation of start-jobs that jobs that should have been started between midnight and now
        ; are started
        (start-jobs {day-now {0 0 0}} now-ts [] (sort-jobs (erl/++ jobs-past jobs-todo)))))))


;; gsrv callbacks
(defn+ init (args)
    {:ok args 5000})


(defn+ handle_call (request from state)
  (let ([{last-day last-time} _ _] state)
    (case request
      (:reload-schedule
        (let (jobs (schedule/load)
              {jobs-past jobs-todo} (lists/partition (fn (x) (erl/< (schedule/job-start-time x) last-time)) jobs))
          ; jobs-past cannot be triggered today anymore and jobs-todo can
          {:reply :ok [{last-day last-time} jobs-past (sort-jobs jobs-todo)] 5000}))
      (other
        (log-error "scheduler: message ~p not understood, fix it!" [other])
          {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  (let ([last-ts jobs-past jobs-todo] state)
    (case info
      (:timeout
        (let (now-ts                    (ta/local-time)
             {jobs-past-2 jobs-todo-2}  (start-jobs last-ts now-ts jobs-past jobs-todo))
          {:noreply [now-ts jobs-past-2 jobs-todo-2] 5000}))
      (other
        (log-error "scheduler: handle_info got message ~w, what's this?" [info])
        {:noreply state 5000}))))


(defn+ terminate (reason state)
  :ok)

(defn+ code_change (old-vsn state extra)
  {:ok state})


