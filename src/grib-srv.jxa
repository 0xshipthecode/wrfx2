

(ns grib-srv
  (require gen_server
     httpc lists filename string
     grib-src-def plist
     (erlang :as erl :joxify)
     (calendar :joxify)
     (filelib :joxify)
     (joxa-lists :as jxl)
     (timelib :as ta))
   (use joxa-core cycles network utils))



(defn+ start-link (grib-src params)
  (let* (stor-dir (plist/get :storage-dir params)
         log-f    (plist/get :log-func params))
    ; start a new GRIB server and return the PID
    (gen_server/start_link :grib-srv [grib-src stor-dir log-f] [])))


;; API

(defn+ retrieve-gribs (srv-pid from to at-time delta log-f)
  (gen_server/call srv-pid {:retrieve-gribs from to at-time delta log-f} :infinity))


;; Internal functions

(defn build-file-list (now to-adj latest-cycle cov-from cov-to grib-src files)
  "Build a file list recursively covering the period from <now> to <to-adj>."
  (if (gte cov-to to-adj)
    {cov-from cov-to (lists/usort files)}
    (let* (next-now  (ta/shift-by-hours now 1)
           now-cycle (cull-cycle (get-cycle-for now (grib-src-def/runs grib-src)) latest-cycle))
      (let ([lgrib rgrib] (get-gribs-for-time now now-cycle (grib-src-def/file-hours grib-src)))
        (build-file-list next-now to-adj latest-cycle
                         (ta/min-time cov-from (cycle-fc-to-time lgrib))
                         (ta/max-time cov-to   (cycle-fc-to-time rgrib))
                         grib-src (lgrib . (rgrib . files)))))))


(defn+ compute-manifest (from to at-time delta grib-src)
  "Compute files to be downloaded from source <grib-src> that cover a time span
   between <from> and <to> (inclusive) as available at time <at-time>, also skip
   <delta> last cycles - this can be used to prevent use of a possibly incomplete
   cycle."
  (let* (delay               (grib-src-def/delay grib-src)
         delayed-at          (ta/shift-by-hours at-time (erl/- delay))
         cycle-at-time       (get-cycle-for delayed-at (grib-src-def/runs grib-src))
         latest-avail-cycle  (shift-cycle-by cycle-at-time delta grib-src)
         from-adj            (ta/round-hours from :down)
         to-adj              (ta/round-hours to :up))
    (let ({cov-from cov-to infolst} (build-file-list from-adj to-adj latest-avail-cycle from-adj (ta/shift-by-hours from-adj -1) grib-src [])
           namefun (grib-src-def/name-fun grib-src))
      {cov-from cov-to (lists/map (fn (x) (let ({c h} x) (lists/flatten (namefun c h)))) infolst)})))


(defn make-stream-func (stor-dir grib-src log-f)
  "Create a closure that can be mapped over the list of GRIB2 files to download from source <grib-src> and
   streams them into the directory <stor-dir> and logs progress through <log-f>."
  (fn (ident)
    (let* (url (lists/flatten [(grib-src-def/url-prefix grib-src) "/" ident])
           abs-path (lists/flatten [stor-dir "/" (grib-src-def/domain grib-src) "/" ident])
           start-time (calendar/local-time))
      (filelib/ensure-dir abs-path)
      (log-f :info "grib-retr (~p) -> downloading ~p to ~p." [(grib-src-def/name grib-src) ident abs-path])
      (case (httpc/request :get {url []} [] [{:stream, abs-path}])
        ({:ok :saved_to_file} 
          (log-f :info "grib-retr (~p) -> finished downloading ~p after ~p seconds"
                 [(grib-src-def/name grib-src) ident (ta/seconds-elapsed-from start-time)])
          :download-complete)
        (error 
          (log-f :warn "grib-retr (~p) -> failed to download downloading ~p after ~p seconds with error ~p"
                 [(grib-src-def/name grib-src) ident (ta/seconds-elapsed-from start-time) error])
          {:download-fail ident})))))


(defn+ download-gribs (manifest stor-dir grib-src log-f)
  "Downloads grib files identified in <manifest> from grib source <grib-src> and stores them in <stor-dir>.
   Returns any failed downloads in a list, thus an empty list is returned if the function succeeded."
  (let* (downloader  (make-stream-func stor-dir grib-src log-f)
         result-list (pmap downloader (grib-src-def/max-downloads grib-src) manifest))
    (lists/filter (fn (x) (case x (:download-complete :false) (_ :true))) result-list)))


(defn+ find-unreachable-gribs (manifest grib-src)
  "Returns a list of GRIB files missing on the server side from the list <manifest>."
  (let* (prefix (grib-src-def/url-prefix grib-src))
    (lists/filter (fn (f) (erl/not (url-exists? (lists/flatten [prefix "/" f])))) manifest)))


(defn+ remove-local-gribs (manifest stor-dir grib-src)
  "Remove GRIB files from manifest that are already available locally."
  (let* (is-grib-local? (fn (ident stor-dir grib-src)
                          (filelib/is-regular
                            (lists/flatten
                              [stor-dir "/" (grib-src-def/domain grib-src) "/" ident]))))
    (lists/filter (fn (x) (erl/not (is-grib-local? x stor-dir grib-src))) manifest)))


(defn+ retrieve-gribs (from to at-time delta max-delta stor-dir grib-src log-func)
  "Computes the GRIB files needed for the simulation covering the time interval <from> to <to>
   which use <delta> cycles before the last cycle and downloads them from the grib source <grib-src>.
   Files already available in <stor-dir> are not redownloaded.
   Returns one of {cov-from cov-to manifest},
                  :out-of-range,
                  {:missing-gribs list-of-gribs}
                  {:failed-download url}."
  (log-func :info "grib-retr (~p) -> have request with from ~w to ~w at-time ~w delta ~p stor-dir ~p"
            [(grib-src-def/name grib-src) from to at-time delta stor-dir])
  (case (compute-manifest from to at-time delta grib-src)
    ({cov-from cov-to manifest}
      (log-func :info "grib-retr (~p) -> manifest has ~p files covering from ~w to ~w"
                      [(grib-src-def/name grib-src) (erl/length manifest) cov-from cov-to])
      (let* (gribs-to-dl (remove-local-gribs manifest stor-dir grib-src))
        (case (find-unreachable-gribs gribs-to-dl grib-src)
          ; if no gribs missing, use this source
          ([]
            (log-func :info "grib-retr (~p) -> downloading ~p files now"
                      [(grib-src-def/name grib-src) (erl/length gribs-to-dl)])
            (case (download-gribs gribs-to-dl stor-dir grib-src log-func)
              ([]
                (log-func :info "grib-retr (~p) -> all ~p files downloaded succesfully, returning manifest covering ~w to ~w with ~p files"
                                 [(grib-src-def/name grib-src) (erl/length gribs-to-dl) cov-from cov-to (erl/length manifest)])
                {cov-from cov-to (lists/reverse (lists/map (fn (x) (filename/join [stor-dir (grib-src-def/name grib-src) x])) manifest))})
              (failure failure)))
          ; in case of missing GRIBs, download
          (missing-gribs
            (log-func :warn "grib-retr (~p) -> source cannot satisfy request at this time, there are ~p missing gribs."
                            [(grib-src-def/name grib-src) (erl/length missing-gribs)])
            ; hard-coded maximum of going at most two cycles back when looking for grib files
            (if (erl/< delta max-delta)
              (retrieve-gribs from to at-time (incr delta) max-delta stor-dir grib-src log-func)
              {:missing-gribs missing-gribs})))))
          ; could not even compute the manifest
    (:out-of-range
      (log-func :warn "grib-retr (~p) -> source cannot satisfy the request from ~w to ~w"
                      [(grib-src-def/name grib-src) from to])
      :out-of-range)))

;; gen_server callbacks

(defn+ init (args)
    {:ok args})

(defn+ handle_call (request from state)
  (let ([grib-src stor-dir log-f] state)
   (case request
	 ({:retrieve-gribs from-time to-time at-time}
	  ; GRIB files retrieved here
	  {:reply (retrieve-gribs from-time to-time at-time 0 2 stor-dir grib-src log-f) state})
	 (:stop-grib-srv 
	  ; here a termination must be started
	  {:stop :normal :ok state})
	 (other 
	  (log-f :flash ["grib-srv: message ~p not understood, fix it!" other])
	  {:reply :invalid-request state}))))

(defn+ handle_cast (msg state)
  {:noreply state})

(defn+ handle_info (info state)
  {:noreply state})

(defn+ terminate (reason state)
  :ok)

(defn+ code_change (old-vsn state extra)
  {:ok state})

