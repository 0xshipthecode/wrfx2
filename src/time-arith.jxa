;    Second generation WRF execution platform services.
;    Copyright (C) 2013 Martin Vejmelka
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.

;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(ns time-arith
    (require io
             (erlang :as erl :joxify)
             (io_lib :as iol)
             (calendar :as cal :joxify))
    (use joxa-core))


(defn+ shift-by-hours (datetime hrs)
  "Shift an erlang <datetime> by <hrs> hours, positive -> future, negative -> past."
  (let* (gs (cal/datetime-to-gregorian-seconds datetime))
    (cal/gregorian-seconds-to-datetime (+ gs (erl/* hrs 3600)))))


(defn+ shift-by-days (datetime d)
  "Shift an erlang <datetime> by <d> days, positive -> future, negaive -> past."
  (let* (gs (cal/datetime-to-gregorian-seconds datetime))
    (cal/gregorian-seconds-to-datetime (+ gs (erl/* d 86400)))))


(defn+ set-hour (datetime new-h)
  "Set the hour of erlang datetime <datetime> to <h>."
  (let ({date, {h m s}} datetime)
    {date {new-h m s}}))


(defn+ round-hours (datetime how)
  "Round datetime <datetime> to next hour (if how is :up) or to last hour (if how is :down)."
  (case datetime
	({date {h 0 0}} datetime)
	({date {h m s}} 
	 (case how
	       (:down {date {h 0 0}})
	       (:up (shift-by-hours {date {h 0 0}} 1))))))


(defn+ seconds-between (from to)
  "Compute seconds between two datetimes."
  (let* (from-s (cal/datetime-to-gregorian-seconds from)
         to-s (cal/datetime-to-gregorian-seconds to))
    (erl/- to-s from-s)))


(defn+ hours-between (from to)
  "Compute the number of whole hours between <from> and <to> assuming
   that to > from."
   (erl/div (seconds-between from to) 3600))


(defn+ seconds-elapsed-from (from)
  "Compute number of seconds elapsed from <from>.  Useful for measuring time intervals."
  (seconds-between from (cal/local-time)))


(defn+ min-time (t1 t2)
  "Find the earlier time from the two datetimes <t1> and <t2>."
  (if (erl/< t1 t2) t1 t2))


(defn+ max-time (t1 t2)
  "Find the later time from the two datetimes <t1> and <t2>."
  (if (erl/> t1 t2) t1 t2))

(defn+ gregorian-seconds-now ()
  "Retrieve seconds since epoch."
  (cal/datetime-to-gregorian-seconds (cal/local-time)))


(defn+ list-hours (from to)
  "List timestamps starting with <from> and incrementing by 1 hour,
   continue until past <to>."
  (if (erl/> from to)
    []
    (from . (list-hours (shift-by-hours from 1) to))))


(defn+ to-esmf-string (dt)
  "Render datetime <dt> as an ESMF date time string YYYY-MM-DD_HH:mm:SS."
  (let ({{y mon day} {h min s}} dt)
    (iol/format "~4..0B-~2..0B-~2..0B_~2..0B:~2..0B:~2..0B" [y mon day h min s])))


(defn+ parse-esmf-str (str)
  "Parse an ESMF date/time string (format: YYYY-MM-DD_HH:mm:SS) <str> into an erlang datetime."
  (let ([y1 y2 y3 y4 :\- m1 m2 :\- d1 d2 :\_ h1 h2 :\: min1 min2 :\: s1 s2] str)
    {{(erl/list-to-integer [y1 y2 y3 y4]) (erl/list-to-integer [m1 m2]) (erl/list-to-integer [d1 d2])}
     {(erl/list-to-integer [h1 h2]) (erl/list-to-integer [min1 min2]) (erl/list-to-integer [s1 s2])}}))


