(ns time-arith
    (require io
             (erlang :as erl)
             (joxa-core :as jxc)
	     (calendar :as cal :joxify)))


(defn+ shift-by-hours (datetime hrs)
  "Shift an erlang <datetime> by <hrs> hours, positive -> future, negative -> past."
  (let* (gs (cal/datetime-to-gregorian-seconds datetime))
    (cal/gregorian-seconds-to-datetime (jxc/+ gs (erl/* hrs 3600)))))


(defn+ shift-by-days (datetime d)
  "Shift an erlang <datetime> by <d> days, positive -> future, negaive -> past."
  (let* (gs (cal/datetime-to-gregorian-seconds datetime))
    (cal/gregorian-seconds-to-datetime (jxc/+ gs (erl/* d 86400)))))


(defn+ set-hour (datetime new-h)
  "Set the hour of erlang datetime <datetime> to <h>."
  (jxc/let ({date, {h m s}} datetime)
    {date {new-h m s}}))


(defn+ round-hours (datetime how)
  "Round datetime <datetime> to next hour (if how is :up) or to last hour (if how is :down)."
  (case datetime
	({date {h 0 0}} datetime)
	({date {h m s}} 
	 (case how
	       (:down {date {h 0 0}})
	       (:up (shift-by-hours {date {h 0 0}} 1))))))


(defn+ hours-between (from to)
  "Compute the number of whole hours between <from> and <to> assuming
   that to > from."
  (let* (s1 (cal/datetime-to-gregorian-seconds from)
	 s2 (cal/datetime-to-gregorian-seconds to))
    (erl/div (erl/- s2 s1) 3600)))


(defn+ min-time (t1 t2)
  "Find the earlier time from the two datetimes <t1> and <t2>."
  (jxc/if (erl/< t1 t2) t1 t2))


(defn+ max-time (t1 t2)
  "Find the later time from the two datetimes <t1> and <t2>."
  (jxc/if (erl/> t1 t2) t1 t2))
