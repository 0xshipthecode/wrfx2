; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns timelib
    (require io
             (erlang :as erl :joxify)
             (io_lib :as iol)
             (calendar :as cal :joxify))
    (use joxa-core))


(defn+ shift-by-seconds (datetime secs)
  "Shift an erlang <datetime> by <secs> seconds positive -> future, negative -> past."
  (let* (gs (cal/datetime-to-gregorian-seconds datetime))
    (cal/gregorian-seconds-to-datetime (erl/+ gs secs))))


(defn+ shift-by-hours (datetime hrs)
  "Shift an erlang <datetime> by <hrs> hours, positive -> future, negative -> past."
  (shift-by-seconds datetime (erl/* hrs 3600)))


(defn+ shift-by-days (datetime d)
  "Shift an erlang <datetime> by <d> days, positive -> future, negaive -> past."
  (shift-by-seconds datetime (erl/* d 86400)))


(defn+ set-hour (datetime new-h)
  "Set the hour of erlang datetime <datetime> to <h>."
  (let ({date, {h m s}} datetime)
    {date {new-h m s}}))


(defn+ round-hours (datetime how)
  "Round datetime <datetime> to next hour (if how is :up) or to last hour (if how is :down)."
  (case datetime
	({date {h 0 0}} datetime)
	({date {h m s}} 
	 (case how
	       (:down {date {h 0 0}})
	       (:up (shift-by-hours {date {h 0 0}} 1))))))


(defn+ seconds-between (from to)
  "Compute seconds between two datetimes."
  (let* (from-s (cal/datetime-to-gregorian-seconds from)
         to-s (cal/datetime-to-gregorian-seconds to))
    (erl/- to-s from-s)))


(defn+ days-hrs-mins-secs-between (from to)
  "Find the number of days/hours/minutes/seconds between <from> and <to> and
   return it as a list."
  (let* (total-seconds (seconds-between from to)
         fold-secs     (fn (d s) {(erl/div s d) (erl/rem s d)}))
    (erl/element 1 (lists/mapfoldl fold-secs total-seconds [86400 3600 60 1]))))


(defn+ hours-between (from to)
  "Compute the number of whole hours between <from> and <to> assuming
   that to > from."
   (erl/div (seconds-between from to) 3600))


(defn+ seconds-elapsed-from (from)
  "Compute number of seconds elapsed from <from>.  Useful for measuring time intervals."
  (seconds-between from (cal/local-time)))


(defn+ min-time (t1 t2)
  "Find the earlier time from the two datetimes <t1> and <t2>."
  (if (erl/< t1 t2) t1 t2))


(defn+ max-time (t1 t2)
  "Find the later time from the two datetimes <t1> and <t2>."
  (if (erl/> t1 t2) t1 t2))


(defn+ gregorian-seconds-now ()
  "Retrieve seconds since epoch."
  (cal/datetime-to-gregorian-seconds (cal/local-time)))


(defn+ local-time ()
  "Retrieve the local time from calendar - convenience function."
  (cal/local-time))

(defn+ universal-time ()
  "Retrieve the current UTC (approx. GMT) - convenience function."
  (cal/universal-time))


(defn+ list-hours (from to)
  "List timestamps starting with <from> and incrementing by 1 hour,
   continue until past <to>."
  (if (erl/> from to)
    []
    (from . (list-hours (shift-by-hours from 1) to))))


(defn+ to-esmf-str (dt)
  "Render datetime <dt> as an ESMF date time string YYYY-MM-DD_HH:mm:SS."
  (let ({{y mon day} {h min s}} dt)
    (iol/format "~4..0B-~2..0B-~2..0B_~2..0B:~2..0B:~2..0B" [y mon day h min s])))


(defn+ parse-esmf (str)
  "Parse an ESMF date/time string (format: YYYY-MM-DD_HH:mm:SS) <str> into an erlang datetime."
  (let ([y1 y2 y3 y4 :\- m1 m2 :\- d1 d2 :\_ h1 h2 :\: min1 min2 :\: s1 s2] str)
    {{(erl/list-to-integer [y1 y2 y3 y4]) (erl/list-to-integer [m1 m2]) (erl/list-to-integer [d1 d2])}
     {(erl/list-to-integer [h1 h2]) (erl/list-to-integer [min1 min2]) (erl/list-to-integer [s1 s2])}}))


(defn+ to-unix-timestamp (dt)
  "Convert a local erlang datetime <dt> to a unix timestamp."
  (- (cal/datetime-to-gregorian-seconds (cal/local-time-to-universal-time dt)) (erl/* 719528 86400)))


(defn+ from-unix-timestamp (ts)
  "Convert a unix timestamp <ts> to an erlang datetime."
  (cal/universal-time-to-local-time (cal/gregorian-seconds-to-datetime (+ ts (erl/* 719528 86400)))))

(defn+ unix-timestamp ()
  "Return a unix timestamp for the current time instant."
  (to-unix-timestamp (local-time)))

