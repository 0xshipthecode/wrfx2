(ns wrfxlib
  (require filesys filename ext-wrappers plist wrf-monitor configsrv
           (steward_job :as sjob :joxify) (steward_utils :as sutils :joxify)
           (erlang :as erl :joxify) (io_lib :as iol :joxify) (filelib :joxify))
  (use joxa-core utils ext-wrappers))


(defn+ clone-wps (src dst vtable add-files)
  "Clone the WPS directory <src> to another location <dst>.
   This function uses a standard list of files that must be symlinked with
   other standard files, such as the <vtable> relative path passed automatically."
  (!!= :ok (filesys/clone-with-files src dst [ "geogrid.exe" "geogrid" "metgrid.exe" "metgrid" "ungrib.exe" "ungrib"]))
  (!!= :ok (filesys/symlink-unless-exists (filename/join src vtable) (filename/join dst "Vtable")))
  (filesys/symlink-files-to-dir add-files src dst))


(defn+ clone-wrf (src dst)
  "Clone the WRF director <src> to another location <dst>.
   Makes symlinks to a standard list of files."
  (filesys/clone-with-files src dst
   ["CAM_ABS_DATA" "CAM_AEROPT_DATA" "co2_trans" "ETAMPNEW_DATA" "ETAMPNEW_DATA_DBL"
    "ETAMPNEW_DATA.expanded_rain" "ETAMPNEW_DATA.expanded_rain_DBL" "GENPARM.TBL"
    "gribmap.txt" "grib2map.tbl" "LANDUSE.TBL" "MPTABLE.TBL" "namelist.fire"
    "ozone.formatted" "ozone_lat.formatted" "ozone_plev.formatted"
    "real.exe" "RRTM_DATA" "RRTM_DATA_DBL" "RRTMG_LW_DATA" "RRTMG_LW_DATA_DBL"
    "RRTMG_SW_DATA" "RRTMG_SW_DATA_DBL" "SOILPARM.TBL" "tc.exe" "tr49t67" "tr49t85"
    "tr67t85" "URBPARM.TBL" "URBPARM_UZE.TBL" "VEGPARM.TBL" "wrf.exe"]))


(defn+ run-geogrid (in-dir log-f)
  (let* (out-spec  (sutils/make-std-output-spec in-dir "geogrid"))
    (log-f :info "running GEOGRID" [])
    (run-process "geogrid" "./geogrid.exe" out-spec in-dir 1800000 log-f 0
      (fn () (exit-check-string-exists (plist/get 1 out-spec) "Successful completion of geogrid.")) 1)
    (log-f :info "geogrid completed successfully" [])
    {:success 0}))


(defn+ run-ungrib (in-dir log-f)
  "Run ungrib.exe in the WPS directory <in-dir> and log progress to using <log-f>."
  (let* (out-spec (sutils/make-std-output-spec in-dir "ungrib"))
    (log-f :info "running UNGRIB" [])
    (run-process "ungrib" "./ungrib.exe" out-spec in-dir 3600000 log-f 0
      (fn () (exit-check-string-exists (plist/get 1 out-spec) "Successful completion of ungrib.")) 1)
    (log-f :info "ungrib completed succesfully." [])))


(defn+ run-metgrid (in-dir log-f)
  "Run metgrid.exe in the WPS directory <in-dir> and log progress using <log-f>."
  (let* (out-spec (sutils/make-std-output-spec in-dir "metgrid"))
    (log-f :info "running METGRID [SERIAL]" [])
    (run-process "metgrid" "./metgrid.exe" out-spec in-dir 3600000 log-f 0
      (fn () (exit-check-string-exists (plist/get 1 out-spec) "Successful completion of metgrid.")) 1)
    (log-f :info "metgrid completed succesfully." [])))


(defn+ run-metgrid-par (in-dir np log-f)
  "Runs metgrid.exe locally using <np> processes on MPI.  Requires the availability of a DMpar installation
   of wrf/wps, logs progress using <log-f>."
  (let* (out-spec (sutils/make-std-output-spec in-dir "metgrid")
         cmd      (iol/format "mpiexec -n ~p -machinefile ../../../etc/machinefile ./metgrid.exe" [np]))
    (log-f :info "running METGRID [DMPAR]" [])
    (run-process "metgrid" cmd out-spec in-dir 18000000 log-f 0
      (fn () (exit-check-string-exists (plist/get 1 out-spec) "Successful completion of metgrid.")) 1)
    (log-f :info "metgrid completed succesfully." [])))


(defn+ run-real (in-dir log-f)
  "Run the (parallel) real.exe in the WRF directory <in-dir> and log progress using <log-f>."
  (let* (cmd          (filename/join in-dir "real.exe")
         out-file     (filename/join in-dir "rsl.out.0000")
         err-file     (filename/join in-dir "rsl.error.0000")
         new-out-file (filename/join in-dir "real.stdout"))
    (log-f :info "running REAL" [])
    (run-process "real" cmd [] in-dir 1800000 log-f 0
      (ext-wrappers/make-exit-check-seq-f [
        (fn () (filesys/copy-unless-dst out-file new-out-file) :passed)
        (fn () (exit-check-string-exists new-out-file "SUCCESS COMPLETE REAL_EM"))]) 1)
    (!!= :ok (filesys/copy-unless-dst err-file (filename/join in-dir "real.stderr")))
    (log-f :info "real completed succesfully" [])))


(defn+ next-grib-suffix (suff)
  "Returns the next suffix in the sequence AAA, AAB, ACC, ..., ZZZ after <suff>."
  (let ([s1 s2 s3] suff)
    (case (+ s3 1)
      (91 (case (+ s2 1)
            (91 (case (+ s1 1)
                  (91 (erl/throw "too many grib files"))
                  (ns3 [ns3 :\A :\A])))
            (ns2 [s1 ns2 :\A])))
      (ns3 [s1 s2 ns3]))))


(defn+ symlink-grib-files (mfest dir)
  "Construct symlinks to the GRIB files in <mfest> in directory <dir> according
   to ungrib.exe requirements.  Assumes that the manifest files <mfest> are ordered
   temporally."
  (lists/foldl (fn (x acc) (filesys/symlink-unless-exists x (filename/join dir (erl/++ "GRIBFILE." acc)))
                           (next-grib-suffix acc)) "AAA" mfest))


(defn monitor-wrf-execution (uuid wdir ext-mon-pid sim-from sim-to wrf-mon-pid wrf-history-hook cfl-violation-hook log-f)
  "Parse the error output of the process with rank 0 in the working
   directory <wdir> while the wrf job with pid <pid> completes."
  (receive
    (:cfl-violation-detected
      (cfl-violation-hook ext-mon-pid)
      (monitor-wrf-execution uuid wdir ext-mon-pid sim-from sim-to wrf-mon-pid wrf-history-hook cfl-violation-hook log-f))
    ({:wrf-history-written domain-id sim-time}
      (wrf-history-hook domain-id sim-time)
      (monitor-wrf-execution uuid wdir ext-mon-pid sim-from sim-to wrf-mon-pid wrf-history-hook cfl-violation-hook log-f))
    ({:proc_started ext-mon-pid comp-start}
      (log-f :info "[~p] WRF computation started on ~w, monitoring" [uuid comp-start])
      (let* (fname            (filename/join wdir "rsl.error.0000")
             real-wrf-mon-pid (wrf-monitor/start fname sim-from sim-to comp-start uuid log-f))
        (monitor-wrf-execution uuid wdir ext-mon-pid sim-from sim-to real-wrf-mon-pid wrf-history-hook cfl-violation-hook log-f)))
    ({:proc_terminated ext-mon-pid result}
      (unless (erl/== :undefined wrf-mon-pid)
        (erl/send wrf-mon-pid :terminate))
      result)
      ; if a :kill is sent, it will land right here
    ({:kill with-reason}
      (log-f :warn "[~p] received kill request with reason ~p." [uuid with-reason])
      (erl/send ext-mon-pid {:kill with-reason})
      (monitor-wrf-execution uuid wdir ext-mon-pid sim-from sim-to wrf-mon-pid wrf-history-hook cfl-violation-hook log-f))))


(defn+ run-wrf (uuid wdir num-nodes ppn wall-time-hrs sim-from sim-to pid-timeout-s wrf-history-hook cfl-violation-hook log-f)
  "Run WRF for job <uuid> in working directory <wdir> on <num-nodes> nodes with <ppn> processors each.
   Wait at most <pid-timeout-s> secods for the job to start (for a PID to be obtained).
   <sim-from> and <sim-to> are the simulation start/end time, passed to the wrf-monitor so that progress
   and completion time can be estimated.
   Use the hooks <wrf-history-hook> and <cfl-violation-hook> to handle new data in wrfout and the
   detection of a CFL violation."
  (let* (wrf-cmd       (filename/join wdir "wrf.exe")
         job-timeout-s (erl/* (erl/+ wall-time-hrs 0.1) 3600)
         hpc-backend   (configsrv/get-conf :hpc-backend)
         wrf-result (case (sjob/execute "wrf" wrf-cmd wdir num-nodes ppn wall-time-hrs pid-timeout-s job-timeout-s hpc-backend log-f)
                      ({:running ext-mon-pid qid}
                        (log-f :info "[~p] WRF is queued with id ~p" [uuid qid])
                        (monitor-wrf-execution uuid wdir ext-mon-pid sim-from sim-to :undefined wrf-history-hook cfl-violation-hook log-f))
                      (already-done
                        already-done)))
    (log-f :info "[~p] WRF result is ~p" [uuid wrf-result])
    (case wrf-result
      ({:failure with-reason}
        (log-f :error "[~p] WRF reported failure with reason ~p." [uuid with-reason])
        (erl/throw {:failed with-reason}))
      ({:success 0}
        (log-f :info "[~p] WRF succesfully completed." [uuid])
        :ok)
      ({:success other-exit-code}
        (log-f :info "[~p] WRF task failed with exit code ~p" [uuid other-exit-code])
        (erl/throw {:failed :wrf-exit-code other-exit-code}))
      ({:killed with-reason}
        (log-f :info "[~p] WRF task has been killed with reason ~p" [uuid with-reason])
        (erl/throw {:killed with-reason})))))


