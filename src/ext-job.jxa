; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns ext-job
    (require lists filename io os plist re configsrv
             (file :joxify)
             (filelib :joxify)
             (string :as str)
             (timelib :as ta)
             (io_lib :as iol)
             (erlang :as erl :joxify))
    (use utils joxa-core ext-utils))


(defn+ read-submit-file (fname)
  "Read the submit file <fname> that only contains the date submitted."
  (case (read-ints-from-file fname 2)
    ([qid unix-ts] {qid (ta/from-unix-timestamp unix-ts)})
    ({:error _} :invalid)))


(defn+ begin-monitoring (in-dir tid qid pid-timeout exec-timeout log-f)
  "Begin monitoring the execution of the process <tid> in dir <in-dir>."
  (let ([pid-f exit-code-f] (make-proc-names in-dir tid [".pid" ".exitcode"]))
    (let* (myself  (erl/self)
           pid     (async-send-me {:ext-proc-complete (erl/self) (monitor-process myself in-dir tid :undefined qid exec-timeout log-f)}))
      ;; construct the first watcher that scans for pids
      (async-send-to pid {:pid-msg (wait-for-file pid-f pid-timeout 500)})
      {:running pid qid})))

;
;; construct a job script for the PBS (Portable Batch System)
(defn make-pbs-script (tid in-dir cmd num-nodes ppn wall-time-hrs)
  (iol/format
    (lists/flatten
      [ "#!/usr/bin/env bash\n"
        "#PBS -l nodes=~p:ppn=~p\n"
        "#PBS -l walltime=~p:00:00\n"
        "#PBS -N ~s\n"
        "TID=~p\n"
        "cd ~s\n"
        "mpirun -np ~p ~s &\n"
        "PID=$!\n"
        "echo $PID `date +%s` > $TID.pid\n"
        "wait $PID\n"
        "echo $? `date +%s` > $TID.exitcode\n" ])
    [num-nodes ppn wall-time-hrs tid tid in-dir (erl/* num-nodes ppn) cmd]))


;; construct a job script for the LSF (Load Sharing Facility)
(defn make-lsf-script (tid in-dir cmd num-nodes ppn wall-time-hrs)
  (iol/format
    (lists/flatten
      [ "#!/usr/bin/env bash\n"
        "#BSUB -J ~s\n"
        "#BSUB -R \"span[ptile=~p]\"\n"
        "#BSUB -n ~p\n"
        "#BSUB -W ~p\n"
        "TID=~p\n"
        "cd ~s\n"
        "mpirun -np ~p -hostfile /home/mvejmelka/ibhostfile ~s &\n"
	"echo \"fake job id <1111>\"\n"
        "PID=$!\n"
        "echo $PID `date +%s` > $TID.pid\n"
        "wait $PID\n"
        "echo $? `date +%s` > $TID.exitcode\n" ])
   [tid ppn num-nodes (erl/* 60 wall-time-hrs) tid in-dir (erl/* num-nodes ppn) cmd]))


;; construct a script for OGE (Open Grid Engine)
(defn make-oge-script (tid in-dir cmd num-nodes ppn wall-time-hrs)
  (iol/format
    (lists/flatten
      [ "#$ -S /bin/bash\n"
        "#$ -N ~s\n"
        "#$ -wd ~s\n"
        "#$ -l h_rt=~p:00:00\n"
        "#$ -pe mpi ~p\n"
        "TID=~p\n"
        "cp $PE_HOSTFILE pe_hostfile\n"
        "awk '{for (i=1;i<=$2;i++) print $1}' pe_hostfile > machinefile\n"
        "mpirun --mca plm_rsh_disable_qrsh 1 -np ~p -machinefile machinefile ~s &\n"
        "PID=$!\n"
        "echo $PID `date +%s` > $TID.pid\n"
        "wait $PID\n"
        "echo $? `date +%s` > $TID.exitcode\n" ])
    [tid in-dir wall-time-hrs (erl/* num-nodes ppn) tid  (erl/* num-nodes ppn) cmd]))


(defn make-script (backend tid in-dir cmd num-nodes ppn wall-time-hrs)
  (case backend
    (:pbs  (make-pbs-script tid in-dir cmd num-nodes ppn wall-time-hrs))   ; portable batch system
    (:lsf  (make-lsf-script tid in-dir cmd num-nodes ppn wall-time-hrs))   ; load sharing facility
    (:oge  (make-oge-script tid in-dir cmd num-nodes ppn wall-time-hrs)))) ; open grid engine


(defn strip-qid (rqid)
  "Strip the non-integer part from the raw job id <rqid> and return the integer."
  (case (re/run rqid "([0-9]+)" [{:capture :first :list}])
    ({:match [str-qid]} (erl/list-to-integer str-qid))
    (error              -1)))


(defn+ run (tid command in-dir num-nodes ppn wall-time-hrs pid-timeout exec-timeout log-f)
  "Execute an external process <command> with id <tid> in directory <in-dir> using a job queuing system.
   The process will use <num-nodes> nodes and up to <wall-time-hrs> hours.  The monitor will wait
   <pid-timeout> ms for the execution to commence and then <exec-timeout> for the execution to complete.
   Progress will be logged with <log-f>."
  (let ([pid-f exit-code-f submit-f] (make-proc-names in-dir tid [".pid" ".exitcode" ".submit"]))
    (case (read-exitcode-file exit-code-f)
      ({exit-code end-time}
        ;; just return the exit code we already obtained
        (log-f :info "~s: process completed on ~w with exit code ~p, returning immediately" [tid end-time exit-code])
        {:success exit-code})
      (:invalid
        (log-f :info "~s: no exit code found, will check pid file ~s" [tid pid-f])
        (case (read-pid-file pid-f)
          ({os-pid start-time}
            (let* (remaining-exec-timeout (- exec-timeout (erl/* (ta/seconds-elapsed-from start-time) 1000)))
              (let ({qid submit-time}     (read-submit-file submit-f))
                (log-f :info "~s: found pid file with pid ~p, process started on ~w, job id is ~p, waiting for completion another ~p ms"
                             [tid os-pid start-time qid remaining-exec-timeout])
              (begin-monitoring in-dir tid qid pid-timeout remaining-exec-timeout log-f))))
          (:invalid
            (log-f :info "~s: no pid file found, checking for submission file ~p" [tid submit-f])
            (case (read-submit-file submit-f)
              ({qid submit-time}
                (let* (remaining-pid-timeout (- pid-timeout (erl/* (ta/seconds-elapsed-from submit-time) 1000)))
                  (log-f :info "~s: already submitted on ~w, job id is ~p waiting for job start for another ~p ms"
                               [tid qid submit-time remaining-pid-timeout])
                  (begin-monitoring in-dir tid qid remaining-pid-timeout exec-timeout log-f)))
              (:invalid
                (log-f :info "~s: job has not been submitted yet, submitting job now" [tid])
                (let* (fqn     (make-proc-file-name in-dir tid ".sh")
                       backend (configsrv/get-conf :hpc-backend))
                  (write-run-script fqn (make-script backend tid in-dir command num-nodes ppn wall-time-hrs))
                  (let* (raw-qid (lists/flatten (os/cmd (lists/flatten ["cd " in-dir " && qsub " tid ".sh"])))
                         qid     (strip-qid raw-qid))
                    (file/write-file submit-f (iol/format "~p~n~p~n" [qid (ta/unix-timestamp)]))
                    (begin-monitoring in-dir tid qid pid-timeout exec-timeout log-f)))))))))))


