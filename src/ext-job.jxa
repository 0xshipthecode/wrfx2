(ns ext-job
    (require lists filename io os plist
             (file :joxify)
             (filelib :joxify)
             (string :as str)
             (time-arith :as ta)
             (io_lib :as iol)
             (erlang :as erl :joxify))
    (use utils joxa-core ext-utils))


;; construct an job script
(defn+ make-script (tid cmd num-nodes wall-time-hrs)
  (iol/format
   (lists/flatten
    [ "#!/usr/bin/env bash\n"
      "#PBS -l nodes=~p:ppn=12\n"
      "#PBS -l walltime=~p:00:00\n"
      "#PBS -N ~s\n"
      "TID=~p\n"
      "cd $PBS_O_WORKDIR\n"
      "echo `date +%s` > $TID.submit\n"
      "mpirun -np ~p -hostfile $PBS_NODEFILE ~s &\n"
      "PID=$!\n"
      "echo $PID > $TID.pid"
      "echo `date +%s` >> $TID.pid\n"
      "wait $PID\n"
      "echo $? > $TID.exitcode\n"
      "echo `date +%s` >> $TID.exitcode\n"])
        [num-nodes wall-time-hrs tid tid (erl/* num-nodes 12) cmd]))


(defn+ run (tid command in-dir num-nodes wall-time-hrs pid-timeout exec-timeout log-f)
  "Execute an external process <command> with id <tid> in directory <in-dir> using a job queuing system.
   The process will use <num-nodes> nodes and up to <wall-time-hrs> hours.  The monitor will wait
   <pid-timeout> ms for the execution to commence and then <exec-timeout> for the execution to complete.
   Progress will be logged with <log-f>."
  (let ([pid-f exit-code-f submit-f] (make-proc-names in-dir tid [".pid" ".exitcode" ".submit"]))
    (case (read-exitcode-file exit-code-f)
      ({exit-code end-time}
        ;; just return the exit code we already obtained
        (log-f :info ["~s: process completed on ~w with exit code ~p, returning immediately" tid end-time exit-code])
        {:success exit-code})
      (:invalid
        (log-f :info ["~s: no exit code found, will check pid file ~s" tid pid-f])
        (case (read-pid-file pid-f)
          ({os-pid start-time}
            (let* (remaining-exec-timeout (- exec-timeout (erl/* (ta/seconds-elapsed-from start-time) 1000)))
              (log-f :info ["~s: found pid file with pid ~p, process started on ~w, waiting for completion another ~p ms"
                            tid os-pid start-time remaining-exec-timeout])
              (begin-monitoring in-dir tid pid-timeout remaining-exec-timeout log-f)))
          (:invalid
            (log-f :info ["~s: no pid file found, checking for submission file ~p" tid submit-f])
            (case (read-submit-file submit-f)
              (:invalid
                (log-f :info ["~s: job has not been submitted yet, submitting job now" tid])
                (let* (fqn (make-proc-file-name in-dir tid ".sh"))
                  (write-run-script fqn (make-script tid command num-nodes wall-time-hrs))
                  (erl/open-port {:spawn (lists/flatten ["qsub " fqn])} [{:cd in-dir} :out])
                  (begin-monitoring in-dir tid pid-timeout exec-timeout log-f)))
              (submit-time
                (let* (remaining-pid-timeout (- pid-timeout (erl/* (ta/seconds-elapsed-from submit-time) 1000)))
                  (log-f :info ["~s: already submitted on ~w, waiting for job start for another ~p ms" tid submit-time remaining-pid-timeout])
                  (begin-monitoring in-dir tid remaining-pid-timeout exec-timeout log-f))))))))))


