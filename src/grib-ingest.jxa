;    Second generation WRF execution platform services.
;    Copyright (C) 2013-2014 Martin Vejmelka, UC Denver
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.

;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(ns grib-ingest
    (require
       (erlang :as erl :joxify)
       plist
       (file :joxify)
       (io_lib :as iol :joxify)
       lists
       (dict :joxify)
       gen_server
       grib-src-def
       utils
       logsrv
       (erl_eval :joxify))
    (use joxa-core utils))


(defn+ load-src-def-file (fname)
  "Load a source file <fname> and scan/parse/eval it to obtain a list of sources."
  (case (file/read-file fname)
    ({:ok content}
      (case (utils/eval-erlang (erl/binary-to-list content) (erl_eval/new-bindings))
        ({:value src-list _} src-list)
        (error (erl/throw error))))
    (error (erl/throw error))))


(defn+ check-src-def-file (fname)
  "Check whether the source definition file <fname> contains a list of values (and is parsable)."
  (case (load-src-def-file fname)
    (values (when (erl/is-list values)) :ok)
    (other {:error (lists/flatten (iol/format "Top-level expression is not a list or error ~p." [other]))})))


(defn+ reload-sources (fname reload-command)
  "Reloads the source definition file <fname> and passes the content
   along with the <reload-command> as {reload-command list-of-source} to the ingest server."
  (let* (source-list (load-src-def-file fname))
    (gen_server/call :gribingest {reload-command source-list})))


(defn+ start-link (stor-dir log-f)
  "Start the GRIB server manager that routes requests to appropriate GRIB servers."
  (!!= {:ok _} (gen_server/start_link {:local :gribingest} :grib-ingest [(dict/new) (dict/new) stor-dir log-f] []))
  (reload-sources "etc/ingest/grib.sources" :restart-grib-servers))

;; API

(defn+ find-grib-server (src-name)
  "Return the pid of the a GRIB2 ingest server under the name <src-name>."
  (gen_server/call :gribingest {:find-grib-server src-name}))


(defn+ get-grib-def (src-name)
  "Return the record of the GRIB source <src-name>."
  (case (gen_server/call :gribingest {:find-grib-source src-name})
    ({:ok grib-src} grib-src)
    (:error :no-such-source)))


(defn+ retrieve-gribs (src-name from to at-time timeout-s)
  "Submits a GRIB retrieval request to the GRIB server stored under name <src-name>.  The retrieved GRIB
   files are to cover the time interval from <from> to <to> and be as fresh as possible at time <at-time>.
   The method will fail if the data is not retrieved within <timeout-s> seconds."
  (case (find-grib-server src-name)
    (:no-such-server :no-such-server)
    (grib-srv-pid (gen_server/call grib-srv-pid {:retrieve-gribs from to at-time} (erl/* timeout-s 1000)))))


;; Internal functions

(defn start-servers (src-list get-mod-name-f stor-dir log-f)
  "Start a source server for each dictionary entry in <src-list>
   and store the mapping name -> pid in a dict that is returned."
  (let* (param-dict   [ {:storage-dir stor-dir} {:log-func log-f} ] 
         start-one    (fn (src) (case (erl/apply (get-mod-name-f src) :start-link [src param-dict]) ({:ok pid} pid))))
    (dict/fold (fn (src-name src d) (dict/store src-name (start-one src) d)) (dict/new) src-list)))


;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn find-server (name d)
  (case (dict/find name d)
    ({:ok srv-pid} srv-pid)
    (_ :no-such-server)))


(defn+ handle_call (request from state)
  "Handle a call request (synch request/reply)."
  (let ([grib-srv-map grib-srcs stor-dir log-f] state)
  (case request
    ({:find-grib-server src-name}
      {:reply (find-server src-name grib-srv-map) state})
    ; find and return a GRIB source record
    ({:find-grib-source src-name}
      {:reply (dict/find src-name grib-srcs) state})
    ; reload GRIB sources file - send kill messages to all current GRIB src and create new ones
    ({:restart-grib-servers new-grib-src-list}
      (log-f :info "ingest_grib/handle_call: restarting GRIB servers" [])
      (let* (new-grib-srcs (lists/foldl (fn (x d) (dict/store (grib-src-def/name x) x d)) (dict/new) new-grib-src-list)
             new-srv-map (start-servers new-grib-srcs (fn (x) (grib-src-def/mod-name x)) stor-dir log-f))
        ; send termination requests to all current gen_servers
        (dict/fold (fn (k v a) (gen_server/call v :stop-grib-srv) :ok) :ok grib-srv-map)
          {:reply :ok [new-srv-map new-grib-srcs stor-dir log-f]}))
    ; catch-all reply indicating failure, should be sent to logger
    (other
      (logsrv/error :flash "grib-ingest/handle_call: message ~p not understood" other)
      {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

