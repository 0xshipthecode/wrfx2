; Copyright (C) 2013-2015 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns utils
    (require lists (filelib :joxify) timer erl_scan erl_parse (erl_eval :joxify)
             (file :joxify) (string :as str) (io_lib :as iol) (erlang :as erl :joxify)
             (joxa-lists :as jxl) (crypto :joxify) (error_logger :as errlog :joxify)
             (pgsql_manager :as dbif :joxify))
    (use joxa-core))



(defn+ empty? (lst)
  "Check if list is empty."
  (case lst
    ([] :true)
    (_ :false)))


(defn+ str-to-num (lst)
  "Convert string <lst> to a number.  First tries float, then integer.
   Throws a badarg exception if string is not a number."
  (try* (erl/list-to-float lst)
    (catch (type body) (erl/list-to-integer lst))))


;; format a task error tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-error (str &rest args)
  {:failure (lists/flatten (io_lib/format str args))})


;; format a task success tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-success (str &rest args)
  {:success (lists/flatten (io_lib/format str args))})


;; opens file file-name with mode mode and
;; passes the device to func/1
;; after function is executed, the device is closed
(defn+ with-file (file-name mode func)
  (case (file/open file-name mode)
    ({:ok device}
      (let* (res (func device))
        (file/close device)
        {:success res}))
      ({:error reason} {:failure reason})))


(defn+ with-file-content (file-name func)
  "Read in the file content of <file-name> and execute
   the function <func> on it.  If unsuccesfull reading
   the data, return {:error reason}."
  (case (file/read-file file-name)
    ({:ok data} (func (erl/binary-to-list data)))
    ({:error reason} {:error reason})))


;; sends a message to multiple targets
(defn+ multicast (msg targets)
  "Send a message <msg> to a list of targets <targets>."
  (lists/foreach (fn (tgt) (erl/send tgt msg)) targets))


(defn+ wait-for-file (file-name timeout-ms file-wait-chunk-ms)
  "Wait for the file <file-name> to appear on the filesystem for <timeout-ms> ms.
   The file is checked every <file-wait-chunk-ms> ms."
  (if (filelib/is-regular file-name)
    {:success file-name}
    (if (erl/> timeout-ms file-wait-chunk-ms)
      (do
        (timer/sleep file-wait-chunk-ms)
        (io/format "waiting for file ~p timeout ~p wait-chunk ~p~n" [file-name timeout-ms file-wait-chunk-ms])
        (wait-for-file file-name (- timeout-ms file-wait-chunk-ms) file-wait-chunk-ms))
      {:failure :timeout})))


(defn+ eval-erlang (str env)
  "Evaluate an erlang expression <str> in the environment <env>."
  (case (erl_scan/string str)
    ({:ok scanned _}
      (case (erl_parse/parse_exprs scanned)
        ({:ok parsed} (erl_eval/exprs parsed env))
        ({:error info} {:error :parse info})))
      ({:error err-info err-loc} {:error :scan {err-info err-loc}})))


(defmacro+ async-send-me (msg)
  "Execute function f in a new process and send myself the result."
  (let* (myself (gensym))
    `(let* (~myself (erlang/self))
       (erlang/spawn (fn () (erlang/send ~myself ~msg))))))


(defn pmap (func workers max-workers tasks res-list)
  "An implementation of a parallel map that does not preserve the order
   of queries.  Applies <func> to each task in <tasks> and accumulates results
   in <res-list>.  At most <max-workers> are used to apply the functions."
  (let* (me (erl/self)
         wait-for-result (fn (func workers max-workers tasks res-list)
                            (receive
                              ({:done pid res} (pmap func (lists/delete pid workers) max-workers
                                               tasks (res . res-list))))))
    (case tasks
      ([]
        (if (empty? workers) res-list (wait-for-result func workers max-workers [] res-list)))
      ((task . rest)
          (if (erl/< (erl/length workers) max-workers)
            (pmap func ((async-send-me {:done (erl/self) (func task)}) . workers) max-workers rest res-list)
            (wait-for-result func workers max-workers tasks res-list))))))


(defn+ pmap (func max-workers tasks)
  "A parallel map implementation with limited parallelism, i.e.
   only <num-workers> functions <func> are executed simultaneously to
   process the list <tasks>.  The order of <tasks> is not preserved."
  (pmap func [] max-workers tasks []))


(defn+ pmap (func tasks)
  "A parallel map that uses as many processes as there are tasks in <tasks>
   to execute the pmap.  The order of tasks is not preserved."
  (pmap func (erl/length tasks) tasks))


(defn+ execute-file (fname)
  "Scan/parse/evaluate file content of <fname>."
  (case (file/read-file fname)
    ({:ok content}
      (case (eval-erlang (erl/binary-to-list content) (erl_eval/new-bindings))
        ({:value result _} {:ok result})
        (error error)))
  (error error)))


(defn+ execute_file (fname) (execute-file fname))

(defmacro+ !!= (form func)
  "Throws an error if the result of <func> does not match <res-check>."
  (let* (other (gensym))
    `(case  ~func
      (~form :ok)
      (~other (erl/throw ~other)))))


(defn grep-device (dev for-what)
  "Keep reading lines from device <dev> until either: eof is reached (returns :not-found),
   an error occurs (returns :error) or <for-what> is a substring
   in one of the lines (returns :found)."
  (case (file/read-line dev)
    (:eof :not-found)
    ({:error _} :error)
    ({:ok line} (case (str/str line for-what)
                  (0 (grep-device dev for-what))
                  (_ :found)))))


(defn+ grep-file (fname for-what)
  "Scan the file <fname> for the occurrence of the string <for-what>.
   Returns either :found or :not-found.  Throws an exception if <fname> cannot
   be opened for reading."
  (let ({:ok dev} (file/open fname [:read]))
    (let* (result (grep-device dev for-what))
      (file/close dev)
      result)))


(defn+ debug-log ()
  "A logging function that's useful for debugging.
   Sends all log output to stdout."
  (fn (level lst)
    (io/format "debug [~p] " [level])
    (io/format (jxl/hd lst) (jxl/tl lst))
    (io/format "~n")))


(defn+ make-uuid ()
  "Creates a long UUID.  Shamelessly ripped from afiscon/rlang-uuid-4 repo on github."
  (let (<<(a :size 32) (b :size 16) (c :size 16) (d :size 16) (e :size 48)>>  (crypto/rand-bytes 16))
    (lists/flatten
      (iol/format "~8.16.0b-~4.16.0b-4~3.16.0b-~4.16.0b-~12.16.0b"
                  [a, b, (erl/band c 4095) (erl/bor (erl/band d 16383) 32768) e]))))


(defmacro+ != (a b)
  "A not-equal macro to get rid of ugly syntax in joxa.
   Returns true if not <a> == <b> in the erlang == sense."
  `(erl/:'/=' ~a ~b))


(defn wait-for-task-set (msg-keys results)
  (case msg-keys
    ([]
      results)
    (not-empty
      (receive
        ({:kill with-reason}
          (erl/throw {:killed with-reason}))
        ({key result}
          (case (lists/member key msg-keys)
            (:true 
              (wait-for-task-set (lists/delete key msg-keys) ({key result} . results)))
            (:false
              (erl/throw {:invalid-key-in-wait key}))))))))


(defn+ wait-for-task-set (msg-keys)
  "Wait for a set of messages in the form {key result} until all keys in <msg-keys> have been
   exhausted.  Each key is associated with a result and the resulting plist is returned."
  (wait-for-task-set msg-keys []))


(defn+ term-to-string (et)
  "Convert en erlang term to a string."
  (iol/format "~p." [et]))


(defn+ string-to-term (str)
  "Converts a string to an erlang term. Returns {:ok term} on success,
   otherwise returns {:error err-type err-info}."
  (case (eval-erlang str (erl_eval/new-bindings))
    ({:value et _} et)))


(defn+ binary-to-term (bin)
  "Convert a binary to an erlang term via string-to-term/1."
  (string-to-term (erl/binary-to-list bin)))
    

(defn+ record-fields (finfo)
  "Map the result of joxa-records/field-info <finfo> into a list of field names."
  (lists/map (fn (field) (erl/element 1 field)) finfo))


(defn+ log-info (arg)
  "Add an INFO report to the log. If <arg> is an iolist, applies lists/flatten, else no modification."
  (errlog/info-report (if (erlang/is-list arg) (lists/flatten arg) arg)))

(defn+ log_info (arg) (log-info arg))


(defn+ log-info (fmt args)
  "Adds an INFO report to the log.  <fmt> must be a string and <args> must be a list of arguments.
   Both are passed to iol/format."
  (log-info (iol/format fmt args)))


(defn+ log_info (fmt args) (log-info fmt args))

(defn+ log-warn (arg)
  "Add an WARN report to the log. If <arg> is an iolist, applies lists/flatten, else no modification."
  (errlog/warning-report (if (erlang/is-list arg) (lists/flatten arg) arg)))


(defn+ log-warn (fmt args)
  "Adds an WARN report to the log.  <fmt> must be a string and <args> must be a list of arguments.
   Both are passed to iol/format."
  (log-warn (iol/format fmt args)))


(defn+ log-error (arg)
  "Add an ERROR report to the log. If <arg> is an iolist, applies lists/flatten, else no modification."
  (errlog/error-report (if (erlang/is-list arg) (lists/flatten arg) arg)))


(defn+ log-error (fmt args)
  "Adds an ERROR report to the log.  <fmt> must be a string and <args> must be a list of arguments.
   Both are passed to iol/format."
    (log-error (iol/format fmt args)))

(defn+ log_error (fmt args) (log-error fmt args))

(defn+ table-exists? (name)
  "Check if a table exists (within a database implicitly specified by conn-id."
  (case (dbif/extended-query "select * from information_schema.tables where table_name = $1" [name])
    ({{:select 1} _} :true)
    (_               :false)))


(defn+ preflight-check (items)
  "Run some sanity checks on parameters given to a job."
  (case items
    ([] [])
    (({:dir-exists path err-msg} . rest)
      (if (filelib/is-dir path) (preflight-check rest) ({err-msg path} . (preflight-check rest))))
    (({:file-exists path err-msg} . rest)
      (if (filelib/is-regular path) (preflight-check rest) ({err-msg path} . (preflight-check rest))))
    (({:is-pid maybe-pid err-msg} . rest)
      (if (erl/is-pid maybe-pid) (preflight-check rest) ({err-msg maybe-pid} . (preflight-check rest))))
    (({:positive-integer int0 err-msg} . rest)
      (if (erl/and (erl/is-integer int0) (erl/> int0 0)) (preflight-check rest) ({err-msg int0} . (preflight-check rest))))))

