;    Second generation WRF execution platform services.
;    Copyright (C) 2013 Martin Vejmelka
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.

;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(ns utils 
    (require lists io_lib filelib timer
             erl_scan erl_parse
             (erl_eval :joxify)
             (mnesia :joxify)
             (file :joxify)
             (string :as str)
             (io_lib :as iol)
             (erlang :as erl :joxify)
      	     (joxa-core :as jxc)
             (joxa-lists :as jxl)))


(defn+ sign (val)
  "Return sign of number, 0 -> 0, x < 0 -> -1, x > 0 -> 1."
  (case val
	(0 0)
	(v (when (erl/< v 0)) -1)
	(v 1)))


(defn+ zero? (val)
  "Check if a value is zero."
  (case val
	(0 :true)
	(_ :false)))


(defn+ empty? (lst)
  "Check if list is empty."
  (case lst
    ([] :true)
    (_ :false)))


(defn+ str-to-num (lst)
  "Convert string <lst> to a number.  First tries float, then integer.
   Throws a badarg exception if string is not a number."
  (try* (erl/list-to-float lst)
    (catch (type body) (erl/list-to-integer lst))))


(defmacro+ critical-check (succ-result func)
  "The function <func> must succeed, i.e return the result <succ-result>.  If not
   the message <fail-msg> is written to file 'critical_failure.log' in the root directory
   the system and an exception is thrown."
   (let* (other (jxc/gensym)
          msg   (jxc/gensym))
    `(case ~func
      (~succ-result :ok)
      (~other
        (let* (~msg (iol/format "FAILURE in ~p: expected ~p instead returned ~p" [(quote ~func) ~succ-result ~other])) 
          (file/write-file "critical_failure.log" ~msg) 
          (erl/throw ~msg))))))


(defn+ ensure-table-exists (tuple-fields index-fields)
  "Ensure that a table either exists or is created with fields <tuple-fields>
   and indices for <index-fields>.  The table name is (jxl/hd tuple-fields)."
  (jxc/if (lists/member (jxl/hd tuple-fields)(mnesia/system-info :tables))
    :ok
    (utils/critical-check {:atomic :ok}
                          (mnesia/create-table (jxl/hd tuple-fields)
                                               [{:attributes (jxl/tl tuple-fields)}
                                               {:index index-fields}
                                               {:disc_copies [(erl/node)]}]))))
 

;; define a macro that matches an arbitrary structure to
;; a single function argument
(defmacro+ fnm1 (args body)
  (let* (arg (jxc/gensym))
    `(fn (~arg) (jxc/let (~args ~arg) ~body))))


;; format a task error tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-error (str &rest args)
  {:failure (lists/flatten (io_lib/format str args))})


;; format a task success tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-success (str &rest args)
  {:success (lists/flatten (io_lib/format str args))})


;; opens file file-name with mode mode and
;; passes the device to func/1
;; after function is executed, the device is closed
;; TODO: try/catch block should be added
(defn+ with-file (file-name mode func)
  (case (file/open file-name mode)
	({:ok device}
	 (let* (res (func device))
	   (file/close device)
	   {:success res}))
	({:error reason} {:failure reason})))


;; read in a file that contains a single integer
;; return the integer or :invalid if the file was unreadable for any reason
(defn+ read-int-from-file (fqn)
    (case (file/read_file fqn)
	  ({:ok data} 
	   (let* (stripped (str/strip (erl/binary_to_list data) :right 10))
	     (erl/list_to_integer stripped)))
	  ({:error reason} 
	   :invalid)))


(defn+ read-ints-from-file (fqn)
  (case (file/read-file fqn)
    ({:ok data}
      (let* (tokens (str/tokens data " \n"))
        (lists/map (fn (x) (erl/list-to-integer (erl/binary-to-list x))) tokens)))
    ({:error reason}
     :invalid)))


;; sends a message to multiple targets
(defn+ multicast (msg targets)
  "Send a message <msg> to a list of targets <targets>."
  (lists/foreach (fn (tgt) (erl/send tgt msg)) targets))


;; use of this macro requires the namespace erlang is required
(defmacro+ async-send-me (f)
  "Execute function f in a new process and send myself the result."
  (let* (myself (jxc/gensym))
    `(let* (~myself (erlang/self))
       (erl/spawn (fn () (erl/send ~myself ~f))))))


;; execute the task in a separate process and send result
;; to given target process
(defn+ async-send-to (tgt f)
  `(erl/spawn (fn () (erl/send ~tgt ~f))))


;; keep waiting for a file to appear for a defined time
;; or infinitely (it timeout is :infinite)
;; this code checks every file-wait-chunk-ms milliseconds whether
;; the file has appeared
(defn+ wait-for-file (file-name timeout file-wait-chunk-ms)
  "Wait for a file to appear on the filesystem."
  (jxc/if (jxc/or (erl/== timeout 'infinite) (erl/> timeout 0))
          (jxc/if (filelib/is_file file-name)
	          {:success file-name}
	          (do (timer/sleep file-wait-chunk-ms)
	              (wait-for-file file-name (erl/- timeout file-wait-chunk-ms) file-wait-chunk-ms)))
          {:failure :timeout}))


(defn+ eval-erlang (str env)
  "Evaluate an erlang expression <str> in the environment <env>."
  (case (erl_scan/string str)
    ({:ok scanned _} 
	    (case (erl_parse/parse_exprs scanned)
        ({:ok parsed} (erl_eval/exprs parsed env))
        ({:error info} {:parse-error info})))
      ({:error err-info err-loc} {:scan-error err-info err-loc})))


(defn pmap (func workers max-workers lst res-list)
  (let* (me (erl/self)
         wait-for-result (fn (func workers max-workers lst res-list)
                            (receive
                              ({:done pid res} (pmap func (lists/delete pid workers) max-workers
                                               lst (res . res-list))))))
  (case lst
    ([] (case workers
          ([] res-list)
          (_notempty (wait-for-result func workers max-workers [] res-list))))
    ((task . rest)
        (jxc/if (erl/< (erl/length workers) max-workers)
          (let* (pid (erl/spawn (fn () (erl/send me {:done (erl/self) (func task)}))))
            (pmap func (pid . workers) max-workers rest res-list))
          (wait-for-result func workers max-workers lst res-list))))))


(defn+ pmap (func max-workers tasks)
  "A parallel map implementation with limited parallelism, i.e.
   only <num-workers> functions <func> are executed simultaneously to
   process the list <tasks>.  The order of <tasks> is not preserved."
  (pmap func [] max-workers tasks []))


(defn+ pmap (func tasks)
  "A parallel map that uses as many processes as there are tasks in <tasks>
   to execute the pmap.  The order of tasks is not preserved."
  (pmap func (erl/length tasks) tasks))


(defn+ execute-file (fname)
  "Scan/parse/evaluate file content of <fname>."
  (case (file/read-file fname)
    ({:ok content}
      (case (eval-erlang (erl/binary-to-list content) (erl_eval/new-bindings))
        ({:value result _} {:ok result})
        (error error)))
  (error error)))


(defmacro+ throw-if-not (form func)
  "Throws an error if the result of <func> does not match <res-check>."
  (let* (other (jxc/gensym))
    `(case  ~func
      (~form :ok)
      (~other (erl/throw ~other)))))

