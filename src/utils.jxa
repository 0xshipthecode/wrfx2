;    Second generation WRF execution platform services.
;    Copyright (C) 2013 Martin Vejmelka
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.

;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(ns utils
    (require lists filelib timer erl_scan erl_parse
             (erl_eval :joxify) (mnesia :joxify) (file :joxify)
             (string :as str) (io_lib :as iol) (erlang :as erl :joxify)
             (joxa-lists :as jxl) (crypto :joxify))
    (use joxa-core))


(defn+ sign (val)
  "Return sign of number, 0 -> 0, x < 0 -> -1, x > 0 -> 1."
  (case val
    (0 0)
    (v (when (erl/< v 0)) -1)
    (v 1)))


(defn+ zero? (val)
  "Check if a value is zero."
  (case val
    (0 :true)
    (_ :false)))


(defn+ empty? (lst)
  "Check if list is empty."
  (case lst
    ([] :true)
    (_ :false)))


(defn+ str-to-num (lst)
  "Convert string <lst> to a number.  First tries float, then integer.
   Throws a badarg exception if string is not a number."
  (try* (erl/list-to-float lst)
    (catch (type body) (erl/list-to-integer lst))))


(defmacro+ critical-check (succ-result func)
  "The function <func> must succeed, i.e return the result <succ-result>.  If not
   the message <fail-msg> is written to file 'critical_failure.log' in the root directory
   the system and an exception is thrown."
   (let* (other (gensym)
          msg   (gensym))
    `(case ~func
      (~succ-result :ok)
      (~other
        (let* (~msg (iol/format "FAILURE in ~p: expected ~p instead returned ~p" [(quote ~func) ~succ-result ~other])) 
          (file/write-file "critical_failure.log" ~msg) 
          (erl/throw ~msg))))))


(defn+ ensure-table-exists (tuple-fields index-fields)
  "Ensure that a table either exists or is created with fields <tuple-fields>
   and indices for <index-fields>.  The table name is (jxl/hd tuple-fields)."
  (let* (table-name (jxl/hd tuple-fields)
         attrs      (jxl/tl tuple-fields))
    (if (lists/member table-name (mnesia/system-info :tables))
      :ok
      (utils/critical-check {:atomic :ok}
                            (mnesia/create-table table-name
                                                 [{:attributes attrs}
                                                  {:index index-fields}
                                                  {:disc_copies [(erl/node)]}])))))


;; define a macro that matches an arbitrary structure to
;; a single function argument
(defmacro+ fnm1 (args body)
  (let* (arg (gensym))
    `(fn (~arg) (let (~args ~arg) ~body))))


;; format a task error tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-error (str &rest args)
  {:failure (lists/flatten (io_lib/format str args))})


;; format a task success tuple
;; str and args are passed to a io_lib/format call
(defn+ fmt-success (str &rest args)
  {:success (lists/flatten (io_lib/format str args))})


;; opens file file-name with mode mode and
;; passes the device to func/1
;; after function is executed, the device is closed
(defn+ with-file (file-name mode func)
  (case (file/open file-name mode)
    ({:ok device}
      (let* (res (func device))
        (file/close device)
        {:success res}))
      ({:error reason} {:failure reason})))


(defn+ with-file-content (file-name func)
  "Read in the file content of <file-name> and execute
   the function <func> on it.  If unsuccesfull reading
   the data, return {:error reason}."
  (case (file/read-file file-name)
    ({:ok data} (func (erl/binary-to-list data)))
    ({:error reason} {:error reason})))


;; sends a message to multiple targets
(defn+ multicast (msg targets)
  "Send a message <msg> to a list of targets <targets>."
  (lists/foreach (fn (tgt) (erl/send tgt msg)) targets))


;; use of this macro requires the namespace erlang is required
(defmacro+ async-send-me (msg)
  "Execute function f in a new process and send myself the result."
  (let* (myself (gensym))
    `(let* (~myself (erlang/self))
       (erlang/spawn (fn () (erlang/send ~myself ~msg))))))


;; execute the task in a separate process and send result
;; to given target process
(defmacro+ async-send-to (pid f)
  `(erlang/spawn (fn () (erlang/send ~pid ~f))))


(defn+ wait-for-file (file-name timeout file-wait-chunk-ms)
  "Wait for the file <file-name> to appear on the filesystem for <timeout> ms.
   The file is checked every <file-wait-chunk-ms> ms."
  (if (filelib/is_regular file-name)
    {:success file-name}
    (if (erl/> timeout file-wait-chunk-ms)
      (do
        (timer/sleep file-wait-chunk-ms)
        (wait-for-file file-name (- timeout file-wait-chunk-ms) file-wait-chunk-ms))
      {:failure :timeout})))


(defn+ eval-erlang (str env)
  "Evaluate an erlang expression <str> in the environment <env>."
  (case (erl_scan/string str)
    ({:ok scanned _}
      (case (erl_parse/parse_exprs scanned)
        ({:ok parsed} (erl_eval/exprs parsed env))
        ({:error info} {:parse-error info})))
      ({:error err-info err-loc} {:scan-error err-info err-loc})))


(defn pmap (func workers max-workers tasks res-list)
  "An implementation of a parallel map that does not preserve the order
   of queries.  Applies <func> to each task in <tasks> and accumulates results
   in <res-list>.  At most <max-workers> are used to apply the functions."
  (let* (me (erl/self)
         wait-for-result (fn (func workers max-workers tasks res-list)
                            (receive
                              ({:done pid res} (pmap func (lists/delete pid workers) max-workers
                                               tasks (res . res-list))))))
    (case tasks
      ([]
        (if (empty? workers) res-list (wait-for-result func workers max-workers [] res-list)))
      ((task . rest)
          (if (erl/< (erl/length workers) max-workers)
            (pmap func ((async-send-me {:done (erl/self) (func task)}) . workers) max-workers rest res-list)
            (wait-for-result func workers max-workers tasks res-list))))))


(defn+ pmap (func max-workers tasks)
  "A parallel map implementation with limited parallelism, i.e.
   only <num-workers> functions <func> are executed simultaneously to
   process the list <tasks>.  The order of <tasks> is not preserved."
  (pmap func [] max-workers tasks []))


(defn+ pmap (func tasks)
  "A parallel map that uses as many processes as there are tasks in <tasks>
   to execute the pmap.  The order of tasks is not preserved."
  (pmap func (erl/length tasks) tasks))


(defn+ execute-file (fname)
  "Scan/parse/evaluate file content of <fname>."
  (case (file/read-file fname)
    ({:ok content}
      (case (eval-erlang (erl/binary-to-list content) (erl_eval/new-bindings))
        ({:value result _} {:ok result})
        (error error)))
  (error error)))


(defmacro+ !!= (form func)
  "Throws an error if the result of <func> does not match <res-check>."
  (let* (other (gensym))
    `(case  ~func
      (~form :ok)
      (~other (erl/throw ~other)))))


(defn grep-device (dev for-what)
  "Keep reading lines from device <dev> until either: eof is reached (returns :not-found),
   an error occurs (returns :error) or <for-what> is a substring
   in one of the lines (returns :found)."
  (case (file/read-line dev)
    (:eof :not-found)
    ({:error _} :error)
    ({:ok line} (case (str/str line for-what)
                  (0 (grep-device dev for-what))
                  (_ :found)))))


(defn+ grep-file (fname for-what)
  "Scan the file <fname> for the occurrence of the string <for-what>.
   Returns either :found or :not-found.  Throws an exception if <fname> cannot
   be opened for reading."
  (let ({:ok dev} (file/open fname [:read]))
    (let* (result (grep-device dev for-what))
      (file/close dev)
      result)))


(defn+ debug-log ()
  "A logging function that's useful for debugging.
   Sends all log output to stdout."
  (fn (level lst)
    (io/format "debug [~p] " [level])
    (io/format (jxl/hd lst) (jxl/tl lst))
    (io/format "~n")))


(defn+ make-uuid ()
  "Creates a long UUID.  Shamelessly ripped from afiscon/rlang-uuid-4 repo on github."
  (let (<<(a :size 32) (b :size 16) (c :size 16) (d :size 16) (e :size 48)>>  (crypto/rand-bytes 16))
    (lists/flatten
      (iol/format "~8.16.0b-~4.16.0b-4~3.16.0b-~4.16.0b-~12.16.0b"
                  [a, b, (erl/band c 4095) (erl/bor (erl/band d 16383) 32768) e]))))


(defn+ retry-at-most (num-times wait-ms fail? func)
  "Retry a function <func> at most <num-times> with waiting <wait-ms> between retries.
   Failure is defined as function <fail?> returning true on result of <func>."
  (let* (result (func))
    (if (fail? result)
      (if (erl/> num-times 0)
        (do
          (timer/sleep wait-ms)
          (retry-at-most (decr num-times) wait-ms fail? func))
        result)
      result)))



(defmacro+ != (a b)
  "A not-equal macro to get rid of ugly syntax in joxa.
   Returns true if not <a> == <b> in the erlang == sense."
  `(erl/:'/=' ~a ~b))

