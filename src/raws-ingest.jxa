; Copyright (C) 2013-2014 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(ns raws-ingest
  (require gen_server
    plist
    os io (io_lib :as iol)
    lists
    (string :as str)
    (mnesia :joxify)
    (erlang :as erl :joxify)
    (timelib :as ta)
    (joxa-lists :as jxl))
  (use joxa-core utils))


(defn+ start-link (log-f)
  "Starts the ingest subsystem.  Requires mnesia to be started and ensures that
   the rawsobs and rawsinfo table are available."
  (ensure-table-exists [:rawsobs :ts-and-stcode-tuple :obs-time :observations] [])
  (ensure-table-exists [:rawsinfo :station-code :name :lat :lon :elev :sensors] [])
  (mnesia/wait-for-tables [:rawsobs :rawsinfo] 10000)
  (!!= {:ok _} (gen_server/start_link {:local :rawsingest} :raws-ingest [log-f] [])))



(defn+ debugstart()
  "Start a minimal version of the system to be able to debug the raws ingest."
  (mnesia/create-schema [(erl/node)])
  (mnesia/start)
  (start-link (fn (l t a) (io/format (erl/++ t "\n") a))))



;; API

(defn+ retrieve-observations (station-list from to timeout-s)
  "Retrieve RAWS observations for stations <station-list> for the time interval
   <from> to <to>."
  (gen_server/call :rawsingest {:retrieve-obs station-list from to} (erl/* timeout-s 1000)))


;; Internal functions


(defn+ obs-available? (key)
  "Check if the observation <key>, where <key> is { station-code, obs-list } entry exists in the mnesia table :rawsobs."
  (case (mnesia/dirty-read :rawsobs key)
    ([] :false)
    (nonempty-list :true)))


(defn+ retrieve-observation (key)
  (case (mnesia/dirty-read :rawsobs key)
    ([{:rawsobs key obs-time obss}]
      {obs-time obss})
    ([]
      :na)))


(defn+ download-station-info (st-code log-f)
  "Download the station information."
  (let* (st-info-raw      (os/cmd (lists/flatten ["cd deps/fmda_scraper && ./retrieve_station_info.py " st-code])))
    (let ([st-code st-name lat-str lon-str elev-str sensors-str] (str/tokens st-info-raw ",\n"))
      (let* (sensor-l (str/tokens sensors-str ":")
             lat      (str-to-num lat-str)
             lon      (str-to-num lon-str)
             elev     (str-to-num elev-str))
        {:rawsinfo st-code st-name lat lon elev sensor-l}))))


(defn+ get-station-info (st-code)
  "Retrieve station information either from database or from the mesowest website if the information
   is not available in the database."
  (case (mnesia/dirty-read :rawsinfo st-code)
    ([]
      :na)
    ([st-info]
      st-info)))


(defn read-or-download-station-info (st-code log-f)
  "If station info is not available in database, download it and store it."
  (case (get-station-info st-code)
    (:na
      (let* (st-info (download-station-info st-code log-f))
        (mnesia/transaction (fn () (mnesia/write st-info)) [] 3)
        st-info))
      (st-info
        st-info)))


(defn compute-request-times (rev-missing-times req-size-hours requests)
  (case rev-missing-times
    ([]
      requests)
    (not-empty
      (let ((this-req . rest-of-times) rev-missing-times)
        (let* (request-covers-from (ta/shift-by-hours this-req (erl/- req-size-hours)))
          (compute-request-times (lists/dropwhile (fn (x) (erl/> x request-covers-from)) rest-of-times)
                                 req-size-hours
                                 (this-req . requests)))))))


(defn parse-obs-from-list (lst current-obs)
  (case lst
    ([]
      {current-obs []})
    (not-empty
      (let* (first-row (jxl/hd lst)
             first-char (jxl/hd first-row))
        (if (erl/and (gte first-char :\0) (lte first-char :\9))
        ; it's the start of a new date, sensors start with a letter, whereas a date with a digit
          {current-obs lst}
        ; it's another observation
        (let ([sensor-name obs-val-str obs-var-str] (str/tokens first-row ","))
          (let* (obs-val (if (erl/== obs-val-str "nan") :na (str-to-num obs-val-str))
                 obs-var (if (erl/== obs-var-str "nan") :na (str-to-num obs-var-str)))
            (parse-obs-from-list (jxl/tl lst) ({sensor-name obs-val obs-var} . current-obs)))))))))


(defn parse-and-store-stream (st-code obs-l)
  (case obs-l
    ([]
      :ok)
    ((ts-str . rest)
      (let* (ts     (ta/parse-esmf (lists/sublist ts-str 19))
             ts-id  (ta/round-hours ts :down))
        (let ({obs next-obs} (parse-obs-from-list rest []))
          (mnesia/transaction (fn () (mnesia/write {:rawsobs {ts-id st-code} ts obs}) [] 3))
          (parse-and-store-stream st-code next-obs))))))


(defn download-and-store-obs (st-code timestamp req-hrs sensors)
  "Activates the retrieve_observations.py script from the fmda_scraper package and uses it to retrieve observations
   for station <st-code> for the period <req-hrs> hours until <timestap>.  The observations from <sensors> are downloaded."
  (let* (cmd (iol/format "cd deps/fmda_scraper && ./retrieve_observations.py ~s ~s ~p ~s ../../etc/ingest/obs_var_table"
              [st-code (ta/to-esmf-str timestamp) req-hrs sensors])
         obs (str/tokens (os/cmd cmd) "\n"))
    (parse-and-store-stream st-code obs)))


(defn download-missing-obs (st-code rev-missing-hrs sensors log-f)
  "Splits the missing observations into 24-hr periods with one request per 24-hr interval.
   There requests are then sent to the mesowest server to retrieve the data."
  (let* (next-ts       (ta/shift-by-hours (jxl/hd rev-missing-hrs) 1)
         request-times (compute-request-times (next-ts . rev-missing-hrs) 24 []))
    (log-f :info "[ingest_raws] scheduling requests for times ~w" [request-times])
    (lists/map (fn (x) (log-f :info "ingest_raws: sending request for 24hr data up to ~w from station ~s." [x st-code])
                       (download-and-store-obs st-code x 24 sensors)) request-times)))


(defn+ retrieve-station-obs (station-code from to log-f)
  (log-f :info "[raws ingest] retrieving observations for station ~s" [station-code])
  (try*
    (let* (ts-list      (ta/list-hours from to)
           missing-ts   (lists/filter (fn (x) (erl/not (obs-available? {x station-code}))) ts-list)
           st-info      (read-or-download-station-info station-code log-f)
           sensors-str  (str/join (erl/element 7 st-info) ":"))
      (case missing-ts
        ([]
          (log-f :info "[raws ingest] cache hit, all observations from ~w to ~w for station ~s available in database." [from to station-code]))
        (have-missing-ts
          (log-f :info "[raws ingest] missing ~p observations from ~w to ~w for station ~s." [(erl/length missing-ts) from to station-code])
          (download-missing-obs station-code (lists/reverse missing-ts) sensors-str log-f)))
      {st-info (lists/map (fn (x) (retrieve-observation {x station-code})) ts-list)})
    (catch (type body)
      (do
        (log-f :flash "[raws ingest] error of type ~p (body ~p) encountered during retrieval of observations for station ~s"
            [type body station-code])
        (log-f :error "[raws ingest] stack trace is ~p" [(erl/get-stacktrace)])
        :error))))


(defn+ retrieve-stations-obs (station-list from to max-dl log-f)
  "Retrieve observations for variables <var-list> from <from> to <to> for stations with codes <station-list>.
   Note that <to> is not included in the retrieved times."
  (log-f :info "mwest-retr processing request for stations ~p from ~w to ~w" [station-list from to])
  (let* (res (pmap (fn (x) (retrieve-station-obs x from to log-f)) max-dl station-list))
        (log-f :info "[raws ingest] returning results." [])
    res))


;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn+ handle_call (request from state)
  (let ([log-f] state)
    (case request
      ({:retrieve-obs station-list from-time to-time}
        ; RAWS observations retrieved here
        {:reply (retrieve-stations-obs station-list from-time to-time 2 log-f) state})
      (:stop-raws-srv
        ; here a termination must be initiated
        {:stop :normal :ok state})
      (other
        (log-f :flash ["mwest-srv: message ~p not understood, fix it!" other])
          {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})

(defn+ handle_info (info state)
  {:noreply state})

(defn+ terminate (reason state)
  :ok)

(defn+ code_change (old-vsn state extra)
  {:ok state})

