;    Second generation WRF execution platform services.
;    Copyright (C) 2013 Martin Vejmelka
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.

;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.

;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(ns ingest-srv
    (require 
       (erlang :as erl :joxify)
	     (joxa-core :as jxc)
	     plist
	     (file :joxify)
	     (io_lib :as iol :joxify)
	     lists
	     (dict :joxify)
	     inets
	     gen_server
	     grib-srv
	     grib-src-def
       raws-src-def
       utils
       (erl_eval :joxify)
       mwest-srv))


(defn+ load-src-def-file (fname)
  "Load a source file <fname> and scan/parse/eval it to obtain a list of sources."
  (case (file/read-file fname)
	  ({:ok content}
      (case (utils/eval-erlang (erl/binary-to-list content) (erl_eval/new-bindings))
        ({:value src-list _} src-list)
			  (error error)))
    (error error)))


(defn+ check-src-def-file (fname)
  "Check whether the source definition file <fname> contains a list of values (and is parsable)."
  (case (load-src-def-file fname)
	  (values (when (erl/is-list values)) :ok)
	  (other {:error (iol/format "Top-level expression is not a list or error ~p." [other])})))


(defn+ reload-sources (fname reload-command)
  "Reloads the source definition file <fname> and passes the content
   along with the <reload-command> as {reload-command list-of-source} to the ingest server."
  (let* (file-content (load-src-def-file fname))
    (case file-content
	    (source-list (when (erl/is-list file-content))
	      (gen_server/call :ingest-srv {reload-command source-list}))
	    (other {:error "Top-level expression is not a list."}))))


(defn+ start-link (stor-dir log-f)
  "Start the GRIB server manager that routes requests to appropriate GRIB servers."
  (inets/start)
  (gen_server/start_link {:local :ingest-srv} :ingest-srv [(dict/new) (dict/new) (dict/new) stor-dir log-f] [])
  (reload-sources "etc/ingest/grib.sources" :restart-grib-servers)
  (reload-sources "etc/ingest/raws.sources" :restart-raws-servers))

;; API


(defn+ get-srv-maps ()
  "Get both server dictionaries (grib2 and raws) mapping source names -> server processes."
  (gen_server/call :ingest-srv :get-srv-maps))


(defn+ find-grib-server (src-name)
  "Return the pid of the a GRIB2 ingest server under the name <src-name>."
  (gen_server/call :ingest-srv {:find-grib-server src-name}))


(defn+ find-raws-server (src-name)
  "Return the pid of the a RAWS ingest server under the name <src-name>."
  (gen_server/call :ingest-srv {:find-raws-server src-name}))


(defn+ get-grib-def (src-name)
  "Return the record of the GRIB source <src-name>."
  (case (gen_server/call :ingest-srv {:find-grib-def src-name})
	  ({:ok grib-src} grib-src)
	  (:error :no-such-source)))


(defn+ retrieve-gribs (src-name from to at-time delta timeout)
  "Submits a GRIB retrieval request to the GRIB server stored under name <src-name>.  The retrieved GRIB
   files are to cover the time interval from <from> to <to> and be as fresh as possible at time <at-time>.
   Optionally an earlier cycle can be requested by setting delta > 0."
  (case (find-grib-server src-name)
    (:no-such-server :no-such-server)
    (grib-srv-pid (gen_server/call grib-srv-pid {:retrieve-gribs from to at-time delta} (erl/* timeout 1000)))))


(defn+ retrieve-raws-obs (src-name station-list from to timeout)
  "Submits a request to a source <src-name> that provides RAWS measurements for stations <station-list>
   and for the time period <from> to <to>. Either returns station information and observations or :error,
   in which case the error is logged with :flash priority."
  (case (find-raws-server src-name)
    (:no-such-server :no-such-server)
    (obs-srv-pid (gen_server/call obs-srv-pid {:retrieve-obs station-list from to} (erl/* timeout 1000)))))


;; Internal functions

(defn start-servers (src-list get-mod-f stor-dir log-f)
  "Start a source server for each dictionary entry in <src-list>
   and store the mapping name -> pid in a dict that is returned."
  (let* (param-dict [ {:storage-dir stor-dir} {:log-func log-f} ] 
         start-one (fn (src) (case (erl/apply (get-mod-f src) :start-link [src param-dict]) ({:ok pid} pid))))
    (dict/fold (fn (src-name src d) (dict/store src-name (start-one src) d)) (dict/new) src-list)))


;; gen_server callbacks

(defn+ init (args)
    {:ok args})


(defn find-server (name d)
  (case (dict/find name d)
    ({:ok srv-pid} srv-pid)
    (_ :no-such-server)))


(defn+ handle_call (request from state)
  "Handle a call request (synch request/reply)."
  (jxc/let ([grib-srv-map grib-srcs raws-srv-map stor-dir log-f] state)
  (case request
	  (:get-log-function {:reply log-f state})
	  (:get-srv-maps {:reply {grib-srv-map raws-srv-map} state})
	  ; find the PID of the gen_server managing GRIB source src-name
	  ({:find-raws-server src-name}
	    {:reply (find-server src-name raws-srv-map) state})
	  ({:find-grib-server src-name}
	    {:reply (find-server src-name grib-srv-map) state})
	  ; find and return a GRIB source record
	  ({:find-grib-source src-name}
	    {:reply (dict/find src-name grib-srcs) state})
    ; reload RAWS sources file - send kill messages to current RAWS servers and create new ones
    ({:restart-raws-servers new-raws-src-list}
      (log-f :info ["ingest-srv/handle_call: restarting RAWS servers"])
  	  (let* (new-raws-srcs (lists/foldl (fn (x d) (dict/store (raws-src-def/name x) x d)) (dict/new) new-raws-src-list)
		         new-srv-map (start-servers new-raws-srcs (fn (x) (raws-src-def/mod-name x)) stor-dir log-f))
	      (dict/fold (fn (k v a) (gen_server/call v :stop-raws-srv) :ok) :ok raws-srv-map)
        {:reply :ok [grib-srv-map grib-srcs new-srv-map stor-dir log-f]}))
	  ; reload GRIB sources file - send kill messages to all current GRIB src and create new ones
	  ({:restart-grib-servers new-grib-src-list}
	    (log-f :info ["ingest-srv/handle_call: restarting GRIB servers"])
	    (let* (new-grib-srcs (lists/foldl (fn (x d) (dict/store (grib-src-def/name x) x d)) (dict/new) new-grib-src-list)
		         new-srv-map (start-servers new-grib-srcs (fn (x) (grib-src-def/mod-name x)) stor-dir log-f))
	      ; send termination requests to all current gen_servers
	      (dict/fold (fn (k v a) (gen_server/call v :stop-grib-srv) :ok) :ok grib-srv-map)
	        {:reply :ok [new-srv-map new-grib-srcs raws-srv-map stor-dir log-f]}))
	  ; catch-all reply indicating failure, should be sent to logger
	  (other (log-f :warn ["ingest-srv/handle_call: message ~p not understood." other])
	    {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})
