(ns jobstate
  (require plist utils
           (erlang :as erl :joxify) (file :joxify) (dict :joxify)
            inets gen_server lists)
  (use joxa-core))


; API

(defn+ start-link (job-name)
  "Start the configuration server <log-f>."
  (case (gen_server/start_link :jobstate [job-name (dict/new) []] [])
    ({:ok pid} pid)
    (error (erl/throw ["error starting the job-state server" job-name]))))


(defn+ subscribe (pid)
  "Add the calling process to the list of notification targets of
  jobstate at <pid>."
  (gen_server/call pid {:add-notify-target (erl/self)}))


(defn+ unsubscribe (pid)
  "Remove the calling process to the list of notification targets of
  jobstate at <pid>."
  (gen_server/call pid {:remove-notify-target (erl/self)}))


(defn+ name (pid)
  "Retrieve the name of the jobstate server <pid>."
  (gen_server/call pid :get-name))


(defn+ get (pid key)
  "Get the state stored under the key <key> in the
   state server <pid>."
  (case (gen_server/call pid {:get-state key})
    ({:ok value} value)
    (:error :no-such-key)))

(defn+ keys (pid)
  "Retrieve all keys stored in jobstate pid <pid>."
  (gen_server/call pid :get-keys))


(defn+ get-plist (pid)
  "Retrieve the entire state dictionary stored in
   the jobstate <pid> as a plist."
   (gen_server/call pid :get-plist))


(defn+ get-list (pid ks)
  "Retrieve a list of keys <ks> from the state server <pid>."
  (case (gen_server/call pid {:multi-get-state ks})
    ({:ok vs} vs)
    (:error :no-such-key)))


(defn+ append (pid key value)
  "Append <value> to list stored under <key>."
  (gen_server/call pid {:append key value}))


(defn+ set (pid key value)
  "Retrieve all keys from the configuration server."
  (gen_server/call pid {:set-state key value}))


(defn+ set-plist (pid plst)
  "Set multiple keys to their values stored as a plist <plst> injobstate <pid>."
  (gen_server/call pid {:multiset-state plst}))

; Implementation

(defn+ init (args)
    {:ok args})


(defn notify-targets (lst)
  "Notify all targets in list if pids <lst> that the state in this
   has been updated."
  (lists/map (fn (x) (erl/send x {:state-changed (erl/self)})) lst))


(defn+ handle_call (request from state)
  (let ([job-name state-dict tgts] state)
    (case request
      (:get-name
        {:reply job-name state})
      ({:get-state key}
        {:reply (dict/find key state-dict) state})
      ({:multi-get-state ks}
        (let* (vs (lists/map (fn (x) (dict/find x state-dict)) ks))
          (if (lists/any (fn (x) (case x (:error :true) (_ :false))) vs)
            {:reply :error state}
            {:reply {:ok vs} state})))
      ({:set-state key value}
        (notify-targets tgts)
        {:reply :ok [job-name (dict/store key value state-dict) tgts]})
      ({:append key value}
        (notify-targets tgts)
        {:reply :ok [job-name (dict/append key value state-dict) tgts]})
      ({:multiset-state plst}
        (notify-targets tgts)
        {:reply :ok [job-name (lists/foldl (fn (x d) (let ({k v} x) (dict/store k v d))) state-dict plst) tgts]})
      ({:add-notify-target tgt}
        {:reply :ok [job-name state-dict (tgt . tgts)]})
      ({:remove-notify-target tgt}
        {:reply :ok [job-name state-dict (lists/delete tgt tgts)]})
      (:get-keys
        {:reply (dict/fetch-keys state-dict) state})
      (:get-plist
        {:reply (dict/to-list state-dict) state})
      (other {:reply :invalid-request state}))))


(defn+ handle_cast (msg state)
  {:noreply state})


(defn+ handle_info (info state)
  {:noreply state})


(defn+ terminate (reason state)
  :ok)


(defn+ code_change (old-vsn state extra)
  {:ok state})

