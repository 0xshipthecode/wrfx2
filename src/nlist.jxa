(ns nlist
  (require file nlscanner nlparser lists (plist :joxify)
           (timelib :as ta :joxify) (erlang :as erl :joxify)
           (io_lib :as iol) (joxa-lists :as jxl)
           (string :as str :joxify))
  (use joxa-core))


(defn+ parse (fname nlname)
  (case (nlparser/parse (nlscanner/scan fname))
    ({:ok nls} {:nls nlname nls})
    ({:error {lineno module text}} (erl/throw {:error (lists/flatten (iol/format "~p on line ~p" [text lineno]))}))))


(defn+ render-value (v)
  "Render the value <v> so that it is readable for a FORTRAN parser."
  (case v
    (:false ".false.")
    (:true  " .true.")
    (lst (when (erl/is-list v)) (iol/format "'~s'" [lst]))
    (other (iol/format "~p" [other]))))


(defn+ render-entry (entry)
  "Render an <entry> (= { key values}) as 'key = values' row."
  (let ({key vals} entry)
    [key (lists/duplicate (erl/- 36 (erl/length key)) 32) "=\t" (str/join (lists/map render-value/1 vals) ",\t") " \n"]))


(defn+ render-nlist (nl)
  "Render a namelist <nl> as required by FORTRAN parsers."
  (let ({name entries} nl)
    (lists/flatten ["&" name "\n" (lists/map render-entry/1 entries) "/\n\n"])))


(defn+ render-namelists (nls)
  "Render all namelists in the namelist structure <nls>."
  (let ({:nls _nlname nlists} nls)
    (lists/map render-nlist/1 nlists)))


(defn+ has-nl (nlname nls)
  "Check if the namelists <nls> contain a particular namelist <nlname>."
  (let ({:nls _name nlists} nls)
    (plist/contains nlname nlists)))


(defn+ get-nl (nlname nls)
  "Retrieve the namelist <nlname> from the namelists <nls>."
  (let ({:nls name nlists} nls)
    (plist/get nlname nlists)))


(defn+ set-nl (nlname new-nl nls)
  "Add/update a namelist <new-nl> with name <name> to <nls>."
  (let ({:nls name nlists} nls)
    {:nls name (plist/set nlname new-nl nlists)}))


(defn+ get-entry (nlname key nls)
  "Retrieve the entry <key> from the namelist <nlname> from the namelists <nls>."
  (plist/get key (get-nl nlname nls)))


(defn+ set-entry (nlname key vals nls)
  "Set the entry <key> to values <vals> inside the namelist <nlname> of the namelists <nls>."
  (if (erl/is-list vals)
    (set-nl nlname (plist/set key vals (get-nl nlname nls)) nls)
    (erl/throw "set-entry: vals must be a list")))


(defn update-namelist-entries (entries nls)
  "Update the namelists <nls> with the plist <kvs>."
  (let ({nlname kvs} entries)
    (set-nl nlname (plist/update-with kvs (get-nl nlname nls)) nls)))


(defn+ set-entries (entries nls)
  "Set entries to given keys in the namelists <nls>."
  (lists/foldl (fn (el nl) (update-namelist-entries el nl)) nls entries))


(defn+ update-list (lst val ndx curr acc)
  (case ndx
    ([] (lists/reverse acc lst))
    ((n . rest)
      (case n
        (curr  ; if we are at an index where we want to store our value, we place it
          (case lst
            ([] (update-list [] val rest (incr curr) (val . acc)))
            (_ (update-list (jxl/tl lst) val rest (incr curr) (val . acc)))))
        (_ (case lst
            ([] (erl/throw :update-list-bad-ndx))
            (_nonempty (update-list (jxl/tl lst) val ndx (incr curr) ((jxl/hd lst) . acc)))))))))


(defn+ update-list (ndxs val lst)
  "Store the value <val> at indices <ndx> in list <lst>.
   The list <ndx> must be sorted.
   Extend the list if not long enough but no indeterminate values can be added to the list:
   thus update-list [1,2,3] with val [10] at position [5] is an error because it's unclear
   what should go to position 4."
  (update-list lst val ndxs 1 []))


(defn+ set-nth (ndx val lst acc)
  "Set the value at <ndx> to <val> in list <lst>.  If <ndx> == length(<lst>)+1,
   the value is appended to the list."
  (case lst
    ([]
      (case ndx
        (1 (lists/reverse (val . acc)))
        (_ (erl/throw :set-nth-write-past-end-of-list))))
    (_nonempty
      (case ndx
        (1 (lists/reverse (val . acc) (jxl/tl lst)))
        (_ (set-nth (decr ndx) val (jxl/tl lst) ((jxl/hd lst) . acc)))))))


(defn+ set-nth (ndx val lst)
  "Set the value at <ndx> to <val> in list <lst>.  Appends if write is just past
   end of list.  If <ndx> is not in 1..len(<lst>)+1, an error is thrown."
  (if (erl/< ndx 1) (erl/throw :set-nth-index-less-than-one) (set-nth ndx val lst [])))


(defn get-values-for-dom (nls nlname keys dom)
  (let* (nl (get-nl nlname nls)
         all-dom-vals (plist/get-list keys nl))
    (lists/map (fn (x) (lists/nth dom x)) all-dom-vals)))


(defn set-values-for-dom (nls nlname kvs dom)
  (let* (nl (get-nl nlname nls)
         keys (lists/map (fn (x) (erl/element 1 x)) kvs)
         all-dom-vals (plist/get-list keys nl)
         upd-kv (fn (key val ndx ps) (plist/set key (set-nth ndx val (plist/get key ps)) ps))
         new-nl (lists/foldl (fn (x acc) (let ({key val} x) (upd-kv key val dom acc))) nl kvs))
    (set-nl nlname new-nl nls)))


(defn set-values-for-doms (nls nlname kvs doms)
  (let* (nl (get-nl nlname nls)
         keys (lists/map (fn (x) (erl/element 1 x)) kvs)
         all-dom-vals (plist/get-list keys nl)
         upd-kv (fn (key val ndxs ps) (plist/set key (update-list ndxs val (plist/get key ps)) ps))
         new-nl (lists/foldl (fn (x acc) (let ({key val} x) (upd-kv key val doms acc))) nl kvs))
    (set-nl nlname new-nl nls)))


(defn+ get-wrf-start-time (nls dom)
  (let ([y mon day h min sec]
          (get-values-for-dom nls "time_control"
                              ["start_year" "start_month" "start_day"
                               "start_hour" "start_minute" "start_second"] dom))
    {{y mon day} {h min sec}}))


(defn+ get-wrf-end-time (nls dom)
  (let ([y mon day h min sec]
          (get-values-for-dom nls "time_control"
                              ["end_year" "end_month" "end_day"
                               "end_hour" "end_minute" "end_second"] dom))
      {{y mon day} {h min sec}}))


(defn+ set-wrf-start-time (nls dt doms)
  "Set the start time of the simulation in the namelist <nls> to <dt> for domains <doms>."
  (let ({{y mon day} {h min s}} dt)
    (set-values-for-doms nls "time_control" [{"start_year" y} {"start_month" mon}
                                             {"start_day" day} {"start_hour" h}
                                             {"start_minute" min} {"start_second" s}] doms)))

(defn+ set-wrf-end-time (nls dt doms)
  "Set the end time of the simulation in the namelist <nls> to <dt> for domains <doms>."
  (let ({{y mon day} {h min s}} dt)
    (set-values-for-doms nls "time_control" [{"end_year" y} {"end_month" mon}
                                             {"end_day" day} {"end_hour" h}
                                             {"end_minute" min} {"end_second" s}] doms)))

(defn+ set-wrf-run-time (nls from to)
  "Set the four keys run_days, run_hours, run_minutes, run_seconds in namelist <nls> according
   to the simulation extent <from> to <to>.  This is always set only for domain 1."
  (let ([days hrs mins secs]   (ta/days-hrs-mins-secs-between from to))
    (set-values-for-doms nls "time_control" [{"run_days" days} {"run_hours" hrs}
                                             {"run_minutes" mins} {"run_seconds" secs}] [1])))


(defn+ max-domains (nls)
  "Retrieve the max_dom key from the namelist 'domains' in <nls> if this
   is a WRF namelist or in the share namelist in a WPS namelist."
  (if (has-nl "domains" nls)
    (jxl/hd (get-entry "domains" "max_dom" nls))
    (jxl/hd (get-entry "share" "max_dom" nls))))


(defn+ all-domains (nls)
  "Returns a list of all domains in the namelist <nls>."
  (lists/seq 1 (max-domains nls)))


(defn+ set-wps-start-time (nls dt doms)
  "Set the start time of the WPS preprocessing cycle in the namelist <nls> to <dt> for domains <doms>."
  (let* (dt-str (ta/to-esmf-str dt))
    (set-values-for-doms nls "share" [{"start_date" dt-str}] doms)))


(defn+ get-wps-start-time (nls dom)
  "Return the start time in the WPS namelist <nls> for domain <dom>."
  (io/format "nth element is ~p~n" [(lists/nth dom (get-entry "share" "start_date" nls))])
  (ta/parse-esmf (lists/nth dom (get-entry "share" "start_date" nls))))


(defn+ set-wps-end-time (nls dt doms)
  "Set the end time of the WPS preprocessing cycle in the namelist <nls> to <dt> for domains <doms>."
  (let* (dt-str (ta/to-esmf-str dt))
    (set-values-for-doms nls "share" [{"end_date" dt-str}] doms)))


(defn+ set-ignition (nls ign-ndx ign-spec dom)
 "Sets the ignition position and time in the namelist <nls> from the ignition specification <ign-spec>.
  The <ign-spec> can be either:
    {{ign-lat ign-lon} {ign-tdelta-s ign-tlen-s ign-radius-m}} - ignition latitude/longitude and start/end time
    {{ign-lat1 ign-lon1} {ign-lat2 ign-lon2} {ign-tdelta-s ign-tlen-s}} - ignition lon/lat start to lon/lat end and start/end time
    In the second case the ignition is a line ingition."
 (let* (ign-vars  ["fire_ignition_start_lon" "fire_ignition_start_lat" "fire_ignition_end_lon"
                   "fire_ignition_end_lat" "fire_ignition_radius" "fire_ignition_start_time"
                   "fire_ignition_end_time"]
        ign-ndx-s (erl/integer-to-list ign-ndx)
        igni-vars (lists/map (fn (x) (erl/++ x ign-ndx-s)) ign-vars))
  (case ign-spec
    ({{ign-lat ign-lon} {ign-tdelta ign-tlen ign-radius-m}}
      (let* (igni-vals [ign-lon ign-lat ign-lon ign-lat ign-radius-m ign-tdelta (erl/+ ign-tdelta ign-tlen)])
        (set-values-for-dom nls "fire" (lists/zip igni-vars igni-vals) dom)))
    ({{ign-lat1 ign-lon1} {ign-lat2 ign-lon2} {ign-tdelta ign-tlen}}
      (let* (igni-vals [ign-lon1 ign-lat1 ign-lon2 ign-lat2 200 ign-tdelta (erl/+ ign-tdelta ign-tlen)])
        (set-values-for-dom nls "fire" (lists/zip igni-vars igni-vals) dom))))))



(defn set-ignitions (nls ign-specs dom ign-ndx)
  (case ign-specs
    ([] nls)
    ((ign-spec . rest)
      (set-ignitions (nlist/set-ignition nls ign-ndx ign-spec dom) rest dom (incr ign-ndx)))))


(defn+ set-ignitions (nls ign-specs dom)
  "Set multiple ignitions from a list of ignition specifications <ign-spec> in dom <dom>
   of the namelist <nls>."
  (let* (nls1 (set-values-for-dom nls "fire" [{"fire_num_ignitions" (erl/length ign-specs)}] 2))
    (set-ignitions nls1 ign-specs dom 1)))

