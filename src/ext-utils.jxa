; Copyright (C) 2013 Martin Vejmelka, UC Denver
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
; of the Software, and to permit persons to whom the Software is furnished to do
; so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
; INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
; A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
; SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


(ns ext-utils
  (require filename lists os io logsrv
           (io_lib :as iol)
           (erlang :as erl :joxify)
           (file :joxify)
           (joxa-lists :as jxl)
           (string :as str)
           (timelib :as ta))
  (use joxa-core utils))


(defn+ read-ints-from-file (fname num-ints)
  "Read integers separated by newlines from file <fname>."
  (with-file-content fname
    (fn (data)
      (try*
        (let* (tokens   (str/tokens data " \n")
               to-int-f (fn (x) (erl/list-to-integer (str/strip x)))
               ints     (lists/map to-int-f tokens))
          (if (erl/== num-ints (erl/length ints)) ints {:error :wrong-int-count}))
        (catch (type body)
          {:error {type body}})))))


(defn+ read-ints-from-file-robust (fname num-ints)
  "Read <num-ints> integers from file <fname>.  Try up to
   4 times with 250ms pauses inbetween.  Succeed if a list with
   <num-ints> integers is read in, otherwise fail."
  (let* (fail?  (fn (x)
                  (case x
                    ({:error _} :true)
                    (_ :false))))
  (retry-at-most 4 250 fail? (fn () (read-ints-from-file fname num-ints)))))


(defn+ read-pid-file (fname)
  "Read a pid file <fname> to obtain the pid of the process and
   the time when it was started."
  (case (read-ints-from-file fname 2)
    ([pid unix-ts] {pid (ta/from-unix-timestamp unix-ts)})
    ({:error _} :invalid)))


(defn+ read-exitcode-file (fname)
  "Read the exit code file <fname> to obtain the exitcode of the process and
   the time when it was started."
  (case (read-ints-from-file fname 2)
    ([exit-code unix-ts] {exit-code (ta/from-unix-timestamp unix-ts)})
    ({:error _} :invalid)))


; construct the name of a process output file from
;; run directory, task name and suffix
(defn+ make-proc-filename (in-dir tid suffix)
  (filename/join in-dir (lists/append tid suffix)))


(defn+ make-std-output-spec (in-dir tid)
  "Construct a standard output mapping, where fd 1 is sent to <tid>.stdout and fd 2 is sent to <tid>.stderr"
  [{1 (make-proc-filename in-dir tid ".stdout")}
   {2 (make-proc-filename in-dir tid ".stderr")}])


;; construct the quartet of output filenames of the
;; stdout, stderr pid and exitcode files
;; the stdout and stderr are generated automatically if output-spec is :standard
;; otherwise the output-spec must be a tuple {stdout-f stderr-f} containing absolute
;; path names
(defn+ make-proc-names (in-dir tid suffixes)
  (lists/map (fn (suffix) (make-proc-filename in-dir tid suffix)) suffixes))


(defn+ cleanup-execution-files (in-dir tid)
  "Removes traces of process execution in the form of the pid file and the exitcode file."
  (lists/map file/delete/1 (make-proc-names in-dir tid [".pid" ".exitcode"])))


;; construct and write the BASH run script which executes the file
(defn+ write-run-script (target-file content)
  (file/write-file target-file content)
  (file/change_mode target-file 448)) ;; 448_10 = 700 in octal


;; monitors process execution
;; the monitoring routine effectively represents a state machine which waits for
;; messages from external helper processes.
;; one helper process sends the :pid-msg message with either a pid or a timeout
;; another helper monitors the exitcode file and sends the :exited message
(defn+ monitor-process (master-pid in-dir tid os-pid qid exec-timeout log-f)
  "Monitor the execution of an external process with id <tid> in directory <in-dir>."
  (try*
    (receive
      ;; a kill command comes from an external source and indicates we need to stop the process now
      ({:kill with-reason}
        (case qid
          (:undefined
            (os/cmd (iol/format "kill -9 ~p" [os-pid]))
            (log-f :warn "~s: monitor-process received kill command, OS process with pid ~p terminated" [tid os-pid]))
          (_
            (os/cmd (iol/format "qdel ~p" [qid]))
            (log-f :warn "~s: monitor-process received kill command for scheduled job ~p, called qdel" [tid qid])))
        (cleanup-execution-files in-dir tid)
        {:killed with-reason})

      ;; exit-msg is received when a process exists (message source is in this function)
      ({:exit-msg {:success exit-code-f}} ;; the process exited, capture status
        (let ({exit-code exit-time} (read-exitcode-file exit-code-f))
          (log-f :info "~s: exited with code ~p at ~w" [tid exit-code exit-time])
          {:success exit-code}))

      ;; exit-msg with failure is retrieved e.g. when a timeout occurrs (then reason is :timeout)
      ({:exit-msg {:failure reason}}
        (os/cmd (iol/format "kill -9 ~p" [os-pid]))
        (log-f :error "~s: failed with reason ~p, process ~p killed" [tid reason os-pid])
        :failure)

      ;; pid-msg with failure timeout is received if the .pid file does not appear within timeout
      ;; timeout is short for external processes (and should cover things like filesystem reaction time, etc.)
      ;; but may be long if the external process is a job
      ({:pid-msg {:failure :timeout}} ; pid was not acquired in time limit
        (log-f :error "~s: pid not acquired within timeout" [tid])
        :failure)

      ;; when the pid file appears, it is read in and a new wait period starts
      ({:pid-msg {:success pid-file}} ;; the pid file was created
        (let ({real-os-pid start-time} (read-pid-file pid-file))
          (log-f :info "~s: received pid ~p, process was started on ~w" [tid real-os-pid start-time])
          (erl/send master-pid {:proc-started (erl/self) start-time})
          (let* (remaining-exec-timeout (- exec-timeout (erl/* (ta/seconds-elapsed-from start-time) 1000)))
            (async-send-me {:exit-msg (wait-for-file (make-proc-filename in-dir tid ".exitcode") remaining-exec-timeout 500)})
            (monitor-process master-pid in-dir tid real-os-pid qid exec-timeout log-f))))

      ;; we don:t understand this message, notify
      (unknown-msg
        (logsrv/system-flash "ext-utils task [~s] message not understood [~p]!" [tid unknown-msg])
        (monitor-process master-pid in-dir tid os-pid qid exec-timeout log-f)))

  (catch (ex bdy)
    (do
      ;(log-f :flash "monitor-process: ~s ~p ~p caught exception ~p ~p~n~p" [tid os-pid exec-timeout ex bdy (erl/get-stacktrace)])
      (io/format "monitor-process: ~s ~p ~p caught exception ~p ~p~n~p" [tid os-pid exec-timeout ex bdy (erl/get-stacktrace)])
      (monitor-process master-pid in-dir tid os-pid qid exec-timeout log-f)))))


(defn+ start-monitor-process (in-dir tid qid exec-timeout log-f)
  "Correctly invoke the monitor-process function and wrap it in a erl/send to communicate process result."
  (let* (myself (erl/self))
    (async-send-me {:proc-complete (erl/self) (monitor-process myself in-dir tid :undefined qid exec-timeout log-f)})))



; simplest wait-for-completion stub, which just returns result
;; of the :proc-complete message
;; more sophisticated clients should handle this message themselves
;; must handle these messages:
;;  :proc-started
;;  :proc-complete
;;  {:kill with-reason} (from jobmaster)
(defn+ wait-for-completion (monitor-pid)
  "Blocks until a :proc-complete message is obtained from the correct monitoring procedure <pid>."
  (receive
    ({:proc-started monitor-pid _}
      (wait-for-completion monitor-pid))
    ({:proc-complete monitor-pid result}
      result)
    ({:kill with-reason}   ;kill arrives from jobmaster (or from another monitoring process)
      (erl/send monitor-pid {:kill with-reason})
      (wait-for-completion monitor-pid))))

