(ns ext-utils
  (require filename lists os io
           (io_lib :as iol)
           (erlang :as erl :joxify)
           (file :joxify)
           (joxa-lists :as jxl)
           (string :as str)
           (time-arith :as ta))
  (use joxa-core utils))


(defn+ read-ints-from-file (fname)
  "Read integers separated by newlines from file <fname>."
  (case (file/read-file fname)
    ({:ok data}
      (let* (tokens (str/tokens (erl/binary-to-list data) " \n"))
        (lists/map (fn (x) (erl/list-to-integer (str/strip x))) tokens)))
    ({:error reason} :invalid)))


(defn+ read-int-from-file (fname)
  "A convenience shortcut when only one integer is to be read from <fname>."
  (case (read-ints-from-file fname)
    (:invalid :invalid)
    ([] :invalid)
    ([int] int)))


(defn+ read-pid-file (fname)
  "Read a pid file <fname> to obtain the pid of the process and
   the time when it was started."
  (case (read-ints-from-file fname)
    ([pid unix-ts] {pid (ta/from-unix-timestamp unix-ts)})
    (:invalid :invalid)))


(defn+ read-exitcode-file (fname)
  "Read the exit code file <fname> to obtain the exitcode of the process and
   the time when it was started."
  (case (read-ints-from-file fname)
    ([exit-code unix-ts] {exit-code (ta/from-unix-timestamp unix-ts)})
    (:invalid :invalid)))


(defn+ read-submit-file (fname)
  "Read the submit file <fname> that only contains the date submitted."
  (case (read-ints-from-file fname)
    (:invalid :invalid)
    ([unix-ts] (ta/from-unix-timestamp unix-ts))))


;; construct the name of a process output file from
;; run directory, task name and suffix
(defn+ make-proc-file-name (in-dir tid suffix)
  (filename/join in-dir (lists/append tid suffix)))


(defn+ make-std-output-spec (in-dir tid)
  "Construct a standard output mapping, where fd 1 is sent to <tid>.stdout and fd 2 is sent to <tid>.stderr"
  [{1 (make-proc-file-name in-dir tid ".stdout")}
   {2 (make-proc-file-name in-dir tid ".stderr")}])


;; construct the quartet of output filenames of the
;; stdout, stderr pid and exitcode files
;; the stdout and stderr are generated automatically if output-spec is :standard
;; otherwise the output-spec must be a tuple {stdout-f stderr-f} containing absolute
;; path names
(defn+ make-proc-names (in-dir tid suffixes)
  (lists/map (fn (suffix) (make-proc-file-name in-dir tid suffix)) suffixes))


;; construct and write the BASH run script which executes the file
(defn+ write-run-script (target-file content)
  (file/write-file target-file content)
  (file/change_mode target-file 448)) ;; 448_10 = 700 in octal


;; monitors process execution
;; the monitoring routine effectively represents a state machine which waits for
;; messages from external helper processes.
;; one helper process sends the :pid-msg message with either a pid or a timeout
;; another helper monitors the exitcode file and sends the :exited message
(defn monitor-process (master-pid in-dir tid os-pid exec-timeout log-f)
  "Monitor the execution of an external process with id <tid> in directory <in-dir>."
  (try*
    (receive
      (:kill-9
        (os/cmd (iol/format "kill -9 ~p" [os-pid]))
        (monitor-process master-pid in-dir tid os-pid exec-timeout log-f))
      ({:exit-msg {:success exit-code-f}} ;; the process exited, capture status
        (let ({exit-code exit-time} (read-exitcode-file exit-code-f))
          (log-f :info "~s: exited with code ~p at ~w" [tid exit-code exit-time])
          {:success exit-code}))
      ({:exit-msg {:failure reason}} ; kill the rogue process
        (os/cmd (iol/format "kill -9 ~p" [os-pid]))
        (log-f :error "~s: failed with reason ~p, process ~p killed" [tid reason os-pid])
        :failure)
      ({:pid-msg {:failure :timeout}} ; pid was not acquired in time limit
        (log-f :error "~s: pid not acquired within timeout" [tid])
        :failure)
      ({:pid-msg {:success pid-file}} ;; the pid file was created
        (let ({real-os-pid start-time} (read-pid-file pid-file))
          (log-f :info "~s: received pid ~p, process was started on ~w" [tid real-os-pid start-time])
          (erl/send master-pid {:proc-started (erl/self) start-time})
          (let* (remaining-exec-timeout (- exec-timeout (erl/* (ta/seconds-elapsed-from start-time) 1000)))
            (async-send-me {:exit-msg (wait-for-file (make-proc-file-name in-dir tid ".exitcode") remaining-exec-timeout 500)})
            (monitor-process master-pid in-dir tid real-os-pid exec-timeout log-f))))
      (unknown-msg ;; we don:t understand this message, notify
        (log-f :flash "ext-utils task [~s] message not understood [~p]!" [tid unknown-msg])
        (monitor-process master-pid in-dir tid os-pid exec-timeout log-f)))
  (catch (ex bdy)
    (do
      (log-f :flash "monitor-process: ~p ~p ~p caught exception ~p ~p~n~p" [tid os-pid exec-timeout ex bdy (erl/get-stacktrace)])
      (monitor-process master-pid in-dir tid os-pid exec-timeout log-f)))))


(defn+ begin-monitoring (in-dir tid pid-timeout exec-timeout log-f)
  "Begin monitoring the execution of the process <tid> in dir <in-dir>."
  (let ([pid-f exit-code-f] (make-proc-names in-dir tid [".pid" ".exitcode"]))
    (let* (myself  (erl/self)
           pid     (async-send-me {:ext-proc-complete (erl/self) (monitor-process myself in-dir tid :undefined exec-timeout log-f)}))
      ;; construct the first watcher that scans for pids
      (async-send-to pid {:pid-msg (wait-for-file pid-f pid-timeout 500)})
      {:running pid})))


;; simplest wait-for-completion stub, which just returns result
;; of the :ext-proc-complete message
;; more sophisticated clients should handle this message themselves
(defn+ wait-for-completion (pid)
  "Blocks until a :ext-proc-complete message is obtained from the correct monitoring procedure <pid>."
  (receive
   ({:proc-started pid _} (wait-for-completion pid))
   ({:ext-proc-complete pid result} result)
   (other (io/format "wait-for-completion recvd ~p~n" [other]) (wait-for-completion pid))))


(defmacro+ wrap-run (exec-func)
  "Wrap a standard execution (ext-proc or ext-job) in a function
   that either returns the exit code of the process or fails (throws an error)."
  (let* (pid (gensym)
         error (gensym)
         exit-code (gensym))
    `(case ~exec-func
      ({:running ~pid}
        (case (ext-utils/wait-for-completion ~pid)
          ({:success ~exit-code} ~exit-code)
          (~error (erl/throw ~error))))
      ({:success ~exit-code} ~exit-code))))

